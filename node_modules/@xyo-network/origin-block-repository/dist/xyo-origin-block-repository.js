"use strict";
/*
 * @Author: XY | The Findables Company <ryanxyo>
 * @Date:   Wednesday, 21st November 2018 1:56:39 pm
 * @Email:  developer@xyfindables.com
 * @Filename: xyo-origin-block-repository.ts
 * @Last modified by: ryanxyo
 * @Last modified time: Wednesday, 6th February 2019 10:20:08 am
 * @License: All Rights Reserved
 * @Copyright: Copyright XY | The Findables Company
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const serialization_schema_1 = require("@xyo-network/serialization-schema");
/**
 * An XyoOriginChainNavigator exposes an api for managing
 * an origin chain
 */
class XyoOriginBlockRepository {
    /**
     * Creates an instance of a XyoOriginChainNavigator
     *
     * @param originBlocksStorageProvider A storage provider for storage management
     */
    constructor(originBlocksStorageProvider, serializationService, hashingProvider) {
        this.originBlocksStorageProvider = originBlocksStorageProvider;
        this.serializationService = serializationService;
        this.hashingProvider = hashingProvider;
    }
    /**
     * Removes an origin block from storage if it exists
     *
     * @param originBlockHash The hash of the origin block to remove
     */
    removeOriginBlock(originBlockHash) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.originBlocksStorageProvider.delete(originBlockHash);
        });
    }
    /**
     * Returns true if the block exists in storage corresponding to the hash, false otherwise
     * @param originBlockHash The hash of the block to query
     */
    containsOriginBlock(originBlockHash) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.originBlocksStorageProvider.containsKey(originBlockHash);
        });
    }
    getOriginBlocks(limit, offsetHash) {
        return __awaiter(this, void 0, void 0, function* () {
            const hashes = yield this.getAllOriginBlockHashes();
            // If this is an iterable storage-provider, answer question that way
            if (instanceOfIterableStorageProvider(this.originBlocksStorageProvider)) {
                const result = yield this.originBlocksStorageProvider.iterate({ limit, offsetKey: offsetHash });
                const blocks = result.items.map((keyPair) => {
                    return this.serializationService.deserialize(keyPair.value).hydrate();
                });
                return {
                    list: blocks,
                    totalSize: hashes.length,
                    hasNextPage: result.hasMoreItems
                };
            }
            const offsetIndex = offsetHash ? hashes.findIndex(hash => hash.equals(offsetHash)) : 0;
            if (offsetIndex === -1) {
                return {
                    list: [],
                    totalSize: hashes.length,
                    hasNextPage: false
                };
            }
            const promises = []; // tslint:disable-line:prefer-array-literal
            let index = 0;
            while (index < limit && ((index + offsetIndex) < hashes.length)) {
                promises.push(this.getOriginBlockByHash(hashes[index + offsetIndex]));
                index += 1;
            }
            const boundWitnesses = yield Promise.all(promises);
            return {
                list: boundWitnesses,
                totalSize: hashes.length,
                hasNextPage: (index + offsetIndex) < hashes.length
            };
        });
    }
    /**
     * Returns a list of all of origin blocks in the system
     */
    getAllOriginBlockHashes() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.originBlocksStorageProvider.getAllKeys();
        });
    }
    /**
     * Adds a bound-witness, which is an origin block, to storage. Additionally it updates
     * any indexes that need to be updated
     */
    addOriginBlock(blockHash, originBlock) {
        return __awaiter(this, void 0, void 0, function* () {
            const blockDataValue = originBlock.serialize();
            const blockHashValue = blockHash.serialize();
            yield this.originBlocksStorageProvider.write(blockHashValue, blockDataValue);
        });
    }
    getOriginBlockByHash(hash) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const result = yield this.originBlocksStorageProvider.read(hash);
                if (!result) {
                    return undefined;
                }
                return this.serializationService.deserialize(result).hydrate();
            }
            catch (error) {
                // there was an error getting the key, so return undefined
                return undefined;
            }
        });
    }
    getBlocksThatProviderAttribution(hash) {
        return __awaiter(this, void 0, void 0, function* () {
            const dest = [];
            yield this.recursivelyGetAllBlocksThatProvideAttribution(hash, undefined, dest);
            // This is going to be horribly slow
            return dest.reduce((promiseChain, result) => __awaiter(this, void 0, void 0, function* () {
                const memo = yield promiseChain;
                const h = yield this.hashingProvider.createHash(result.getSigningData());
                memo[h.serializeHex()] = result;
                return memo;
            }), Promise.resolve({}));
        });
    }
    recursivelyGetAllBlocksThatProvideAttribution(hash, currentCursor, dest) {
        return __awaiter(this, void 0, void 0, function* () {
            const results = yield this.getOriginBlocks(1000, currentCursor);
            const matches = results.list.filter((bw) => {
                bw.parties.some((party) => {
                    const bridgeSet = party.getHeuristic(serialization_schema_1.schema.bridgeHashSet.id);
                    if (!bridgeSet) {
                        return false;
                    }
                    return bridgeSet.hashSet.some(hs => hs.serialize().equals(hash));
                });
            });
            dest.push(...matches);
            if (!results.hasNextPage) {
                return;
            }
            const lastItem = results.list[results.list.length - 1];
            const lastHash = yield this.hashingProvider.createHash(lastItem.getSigningData());
            return this.recursivelyGetAllBlocksThatProvideAttribution(hash, lastHash.serialize(), dest);
        });
    }
}
exports.XyoOriginBlockRepository = XyoOriginBlockRepository;
function instanceOfIterableStorageProvider(storageProvider) {
    return 'iterate' in storageProvider;
}
//# sourceMappingURL=xyo-origin-block-repository.js.map