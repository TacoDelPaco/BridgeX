"use strict";
/*
 * @Author: XY | The Findables Company <ryanxyo>
 * @Date:   Wednesday, 21st November 2018 9:50:32 am
 * @Email:  developer@xyfindables.com
 * @Filename: xyo-bound-witness-server-interaction.ts
 * @Last modified by: ryanxyo
 * @Last modified time: Tuesday, 5th February 2019 2:37:22 pm
 * @License: All Rights Reserved
 * @Copyright: Copyright XY | The Findables Company
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.XyoBoundWitnessClientInteraction = void 0;
const base_1 = require("@xyo-network/base");
const bound_witness_1 = require("@xyo-network/bound-witness");
const errors_1 = require("@xyo-network/errors");
const xyo_inner_bound_witness_1 = require("../xyo-inner-bound-witness");
/**
 * An `XyoBoundWitnessInteraction` manages a "session"
 * between two networked nodes.
 */
// tslint:disable-next-line:max-line-length
class XyoBoundWitnessClientInteraction extends base_1.XyoBase {
    constructor(signers, payload, serializationService, catalogueItem) {
        super();
        this.signers = signers;
        this.payload = payload;
        this.serializationService = serializationService;
        this.catalogueItem = catalogueItem;
    }
    /**
     * Does a bound witness with another node
     */
    run(networkPipe, didInit) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!didInit) {
                throw new Error("Server init can not be used in a client interaction!");
            }
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    resolve(yield this.performInteraction(networkPipe));
                }
                catch (err) {
                    reject(err);
                }
            }));
        });
    }
    performInteraction(networkPipe) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logInfo(`Starting bound witness`);
            let disconnected = false;
            /**
             * Listener for if and when the peer disconnects
             */
            const unregister = networkPipe.onPeerDisconnect(() => {
                disconnected = true;
                this.logInfo(`Peer disconnected in xyo-bound-witness-interaction`);
            });
            const keySet = new bound_witness_1.XyoKeySet(this.signers.map(s => s.publicKey));
            const fetter = new bound_witness_1.XyoFetter(keySet, this.payload.heuristics.concat(networkPipe.networkHeuristics));
            console.log(fetter.serializeHex());
            // this is their fetter
            const transferQuery = this.serializationService.deserialize(networkPipe.initiationData).query();
            // create the bound witness object staring with their fetter
            const aggregator = [transferQuery.getChildAt(0).readData(true)];
            // add our fetter to the bound witness
            aggregator.push(fetter.serialize());
            // at this point the bound witness data has been collected so we get the signing data
            const signingData = Buffer.concat(aggregator);
            this.logInfo(`Signing Data`, signingData.toString('hex'));
            const signatures = yield Promise.all(this.signers.map((signer) => {
                return signer.signData(signingData);
            }));
            if (!disconnected) {
                const signatureSet = new bound_witness_1.XyoSignatureSet(signatures);
                const witness = new bound_witness_1.XyoWitness(signatureSet, this.payload.metadata);
                const fragment = new bound_witness_1.XyoBoundWitnessFragment([fetter, witness]);
                aggregator.push(witness.serialize());
                // now we send back the fetter and signature
                const theirSig = yield this.sendMessage(networkPipe, fragment.serialize());
                const otherWitness = this.serializationService.deserialize(theirSig).query();
                aggregator.push(otherWitness.query([0]).readData(true));
                /** Stop listening for disconnect events */
                unregister();
                /** Close the connection */
                yield networkPipe.close();
                const fragmentParts = [];
                aggregator.forEach((item) => {
                    fragmentParts.push(this.serializationService
                        .deserialize(item)
                        .hydrate());
                });
                return new xyo_inner_bound_witness_1.InnerBoundWitness(fragmentParts, signingData);
            }
            throw new errors_1.XyoError(`Peer disconnected in xyo-bound-witness-interaction`, errors_1.XyoErrors.CRITICAL);
        });
    }
    sendMessage(networkPipe, bytesToSend) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let response;
                response = yield networkPipe.send(bytesToSend);
                if (!response) {
                    throw new errors_1.XyoError(`Unexpected undefined response in bound witness interaction`, errors_1.XyoErrors.CRITICAL);
                }
                return response;
            }
            catch (err) {
                this.logError(`Failed BoundWitnessTransfer on step 1`, err);
                throw err;
            }
        });
    }
}
exports.XyoBoundWitnessClientInteraction = XyoBoundWitnessClientInteraction;
//# sourceMappingURL=xyo-bound-witness-client-interaction.js.map