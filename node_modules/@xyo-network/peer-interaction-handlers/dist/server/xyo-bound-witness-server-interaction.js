"use strict";
/*
 * @Author: XY | The Findables Company <ryanxyo>
 * @Date:   Wednesday, 21st November 2018 9:50:32 am
 * @Email:  developer@xyfindables.com
 * @Filename: xyo-bound-witness-server-interaction.ts
 * @Last modified by: ryanxyo
 * @Last modified time: Wednesday, 6th March 2019 4:42:51 pm
 * @License: All Rights Reserved
 * @Copyright: Copyright XY | The Findables Company
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.XyoBoundWitnessServerInteraction = void 0;
const network_1 = require("@xyo-network/network");
const bound_witness_1 = require("@xyo-network/bound-witness");
const errors_1 = require("@xyo-network/errors");
const base_1 = require("@xyo-network/base");
const serialization_1 = require("@xyo-network/serialization");
const xyo_inner_bound_witness_1 = require("../xyo-inner-bound-witness");
/**
 * An `XyoBoundWitnessInteraction` manages a "session"
 * between two networked nodes.
 */
// tslint:disable-next-line:max-line-length
class XyoBoundWitnessServerInteraction extends base_1.XyoBase {
    constructor(signers, payload, serializationService, catalogueItem) {
        super();
        this.signers = signers;
        this.payload = payload;
        this.serializationService = serializationService;
        this.catalogueItem = catalogueItem;
    }
    /**
     * Does a bound witness with another node
     */
    run(networkPipe, didInit) {
        return __awaiter(this, void 0, void 0, function* () {
            if (didInit) {
                throw new Error("Client init can not be used in a server interaction!");
            }
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    resolve(yield this.performInteraction(networkPipe));
                }
                catch (err) {
                    reject(err);
                }
            }));
        });
    }
    performInteraction(networkPipe) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logInfo(`Starting bound witness`);
            let disconnected = false;
            /**
             * Listener for if and when the peer disconnects
             */
            const unregister = networkPipe.onPeerDisconnect(() => {
                disconnected = true;
                this.logInfo(`Peer disconnected in xyo-bound-witness-interaction`);
            });
            const { bytesToSend, fetter } = this.getFirstMessage();
            const response = yield this.sendMessage(networkPipe, bytesToSend);
            const transferQuery = this.serializationService.deserialize(response).query();
            const numberOfItemsInTransfer = transferQuery.getChildrenCount();
            if (numberOfItemsInTransfer < 2 || numberOfItemsInTransfer % 2 !== 0) {
                throw new errors_1.XyoError(`Invalid Bound Witness Fragments`);
            }
            const aggregator = [fetter.serialize()];
            aggregator.push(transferQuery.query([0]).readData(true));
            const signingData = Buffer.concat(aggregator);
            this.logInfo(`Signing Data`, signingData.toString('hex'));
            const signatures = yield Promise.all(this.signers.map((signer) => {
                return signer.signData(signingData);
            }));
            if (!disconnected) {
                const signatureSet = new bound_witness_1.XyoSignatureSet(signatures);
                const witness = new bound_witness_1.XyoWitness(signatureSet, this.payload.metadata);
                const witnessSet = new bound_witness_1.XyoWitnessSet([witness]);
                yield networkPipe.send(witnessSet.serialize(), false);
                /** Stop listening for disconnect events */
                unregister();
                /** Close the connection */
                yield networkPipe.close();
                const fragmentParts = transferQuery.reduceChildren((memo, parseResult) => {
                    memo.push(this.serializationService
                        .deserialize(new serialization_1.ParseQuery(parseResult).readData(true))
                        .hydrate());
                    return memo;
                }, [fetter]);
                fragmentParts.push(witness);
                return new xyo_inner_bound_witness_1.InnerBoundWitness(fragmentParts, signingData);
            }
            throw new errors_1.XyoError(`Peer disconnected in xyo-bound-witness-interaction`);
        });
    }
    getFirstMessage() {
        const keySet = new bound_witness_1.XyoKeySet(this.signers.map(s => s.publicKey));
        const fetter = new bound_witness_1.XyoFetter(keySet, this.payload.heuristics);
        const fetterSet = new bound_witness_1.XyoFetterSet([fetter]);
        /** Tell the other node this is the catalogue item you chose */
        const catalogueBuffer = Buffer.alloc(network_1.CATALOGUE_LENGTH_IN_BYTES);
        catalogueBuffer.writeUInt32BE(this.catalogueItem, 0);
        const sizeOfCatalogueInBytesBuffers = Buffer.alloc(network_1.CATALOGUE_SIZE_OF_SIZE_BYTES);
        sizeOfCatalogueInBytesBuffers.writeUInt8(network_1.CATALOGUE_LENGTH_IN_BYTES, 0);
        /** Build the final message */
        const bytesToSend = Buffer.concat([
            sizeOfCatalogueInBytesBuffers,
            catalogueBuffer,
            fetterSet.serialize()
        ]);
        return { bytesToSend, fetter };
    }
    sendMessage(networkPipe, bytesToSend) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let response;
                response = yield networkPipe.send(bytesToSend);
                if (!response) {
                    throw new errors_1.XyoError(`Unexpected undefined response in bound witness interaction`);
                }
                return response;
            }
            catch (err) {
                this.logError(`Failed BoundWitnessTransfer on step 1`, err);
                throw err;
            }
        });
    }
}
exports.XyoBoundWitnessServerInteraction = XyoBoundWitnessServerInteraction;
//# sourceMappingURL=xyo-bound-witness-server-interaction.js.map