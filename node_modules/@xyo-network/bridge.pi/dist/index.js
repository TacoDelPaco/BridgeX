"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.main = void 0;
const pi_wifi_manager_1 = require("@xyo-network/pi-wifi-manager");
const pi_bridge_server_1 = require("@xyo-network/pi-bridge-server");
const logger_1 = require("@xyo-network/logger");
const origin_block_repository_1 = require("@xyo-network/origin-block-repository");
const origin_chain_1 = require("@xyo-network/origin-chain");
const serializer_1 = require("@xyo-network/serializer");
const ble_central_noble_1 = require("@xyo-network/ble-central.noble");
const network_ble_1 = require("@xyo-network/network.ble");
const bridge_queue_repository_keyvalue_1 = require("@xyo-network/bridge-queue-repository.keyvalue");
const storage_leveldb_1 = require("@xyo-network/storage.leveldb");
const hashing_1 = require("@xyo-network/hashing");
const network_tcp_1 = require("@xyo-network/network.tcp");
const bridge_core_1 = require("@xyo-network/bridge-core");
const ble_peripheral_bleno_1 = require("@xyo-network/ble-peripheral.bleno");
const xyo_bridge_archivist_queue_1 = require("./xyo-bridge-archivist-queue");
const xyo_configuration_endpoints_1 = require("./xyo-configuration-endpoints");
const xyo_password_store_1 = require("./xyo-password-store");
const xyo_archivist_store_1 = require("./xyo-archivist-store");
const pi_wifi_ble_1 = require("@xyo-network/pi-wifi-ble");
const bleno_1 = __importDefault(require("@abandonware/bleno"));
const noble_1 = __importDefault(require("@abandonware/noble"));
let hasMutex = false;
let inConfigureMode = false;
const nobleHandle = (enable) => {
    if (enable) {
        noble_1.default.enable();
    }
    else {
        noble_1.default.disable();
    }
};
const blenoHandle = (enable) => {
    if (enable) {
        bleno_1.default.enable();
    }
    else {
        bleno_1.default.disable();
    }
};
bleno_1.default.on('accept', (address) => {
    logger.info(`BLENO + accept event: ${address}`);
});
bleno_1.default.on("advertisingStart", (err) => {
    logger.info(`BLENO + advertisingStart event: ${err}`);
});
bleno_1.default.on("advertisingStartError", (err) => {
    logger.info(`BLENO + advertisingStartError event: ${err}`);
});
bleno_1.default.on("advertisingStop", () => {
    logger.info(`BLENO + advertisingStop event`);
});
bleno_1.default.on("disconnect", (address) => {
    logger.info(`BLENO + disconnect event: ${address}`);
});
bleno_1.default.on("mtuChange", (mtu) => {
    logger.info(`BLENO + mtuChange event: ${mtu}`);
});
bleno_1.default.on("servicesSet", (err) => {
    logger.info(`BLENO + servicesSet event: ${err}`);
});
bleno_1.default.on("servicesSetError", (err) => {
    logger.info(`BLENO + servicesSetError event: ${err}`);
});
bleno_1.default.on("stateChange", (state) => {
    logger.info(`BLENO + stateChange event: ${state}`);
});
noble_1.default.on("scanStart", () => {
    logger.info(`NOBLE + scanStart event`);
});
noble_1.default.on("scanStop", () => {
    logger.info(`NOBLE + scanStop event`);
});
noble_1.default.on("stateChange", (state) => {
    logger.info(`NOBLE + scanStop event: ${state}`);
});
const hasher = (0, hashing_1.getHashingProvider)('sha256');
const char = new ble_peripheral_bleno_1.BlenoCharacteristic('727a36390eb44525b1bc7fa456490b2d', ["write", "notify"]);
const xyoService = new ble_peripheral_bleno_1.BlenoService("d684352edf36484ebc982d5398c5593e", [char]);
const mutexChar = new ble_peripheral_bleno_1.BlenoCharacteristic('e047295e3df047cda841be2d2a97dd21', ["write", "notify"]);
const adminService = new ble_peripheral_bleno_1.BlenoService("c9be98507a57414ab79764c230d9ecb9", [mutexChar]);
const server = new ble_peripheral_bleno_1.BlenoServer();
const bleServerNetwork = new network_ble_1.XyoServerNetwork(char, server);
const scanner = new ble_central_noble_1.NobleScan();
const bleClientNetwork = new network_ble_1.XyoClientBluetoothNetwork(scanner);
const fullBleNetwork = new network_ble_1.XyoFullBleNetwork(bleClientNetwork, bleServerNetwork, nobleHandle, blenoHandle);
const storageProvider = new storage_leveldb_1.XyoLevelDbStorageProvider(process.env.STORE || "bridge-store", true);
const bridgeQueueRepo = new bridge_queue_repository_keyvalue_1.XyoStorageBridgeQueueRepository(storageProvider);
const blockRepo = new origin_block_repository_1.XyoOriginBlockRepository(storageProvider, serializer_1.serializer, hasher);
const chainRepo = new origin_chain_1.XyoOriginChainLocalStorageRepository(storageProvider, blockRepo, serializer_1.serializer);
const logger = new logger_1.XyoLogger(false, false);
const archivistQueue = new xyo_bridge_archivist_queue_1.XyoBridgeArchivistQueue();
const tcpClient = new network_tcp_1.XyoClientTcpNetwork(archivistQueue.tcpPeerSelector);
const passwordStore = new xyo_password_store_1.XyoPasswordStore(hasher, storageProvider);
const archivistStore = new xyo_archivist_store_1.XyoArchivistStore(archivistQueue, storageProvider);
const piWifi = new pi_wifi_manager_1.PiWifiManager();
const adv = new network_ble_1.XyoAdvertisement(8);
let mutexReleaseSetupCallback;
const defaultArchivists = [
    {
        host: "alpha-peers.xyo.network",
        port: 11000
    }
];
const bridgeConfig = {
    hasher,
    storageProvider,
    bridgeQueueRepo,
    blockRepo,
    chainRepo,
    logger
};
const bridge = new bridge_core_1.XyoBridge(fullBleNetwork, tcpClient, bridgeConfig);
const startPi = () => __awaiter(void 0, void 0, void 0, function* () {
    const port = Number(process.env.PORT) || 13000;
    const configuration = new xyo_configuration_endpoints_1.XyoBridgeConfigurationEndpoint(passwordStore, archivistQueue, archivistStore, chainRepo, storageProvider, bridge);
    const context = {
        port,
        wifi: piWifi,
        configuration: configuration
    };
    const server = new pi_bridge_server_1.BridgeServer(context);
    const wifiService = new pi_wifi_ble_1.NetworkService(piWifi, configuration.verifyPin);
    server.start(() => {
        logger.info(`Server ready at http://localhost:${port}`);
    });
    wifiService.start();
    startBridge(wifiService);
});
const onMutexHold = () => {
    logger.info("On mutex hold");
    if (!hasMutex) {
        if (inConfigureMode) {
            server.stopAdvertising();
        }
        else {
            bleServerNetwork.pause();
        }
        hasMutex = true;
    }
};
/* Debugging noble warning: unknown handle x disconnected! */
const onMutexRelease = () => {
    logger.info("On mutex release");
    if (hasMutex) {
        logger.info("Has mutex");
        if (inConfigureMode) {
            logger.info("isConfiguredMode");
            server.startAdvertising(adv.advertisementData(), adv.getScanResponse());
            logger.info(adv.advertisementData() + " " + adv.getScanResponse());
            const callback = mutexReleaseSetupCallback;
            if (callback) {
                logger.info("callback()");
                callback();
            }
        }
        else {
            logger.info("bleServerNetwork.unPause()");
            bleServerNetwork.unPause();
        }
        logger.info("hasMutex = false");
        hasMutex = false;
    }
};
const mutexListener = {
    onSubscribe: () => {
        onMutexHold();
    },
    onUnsubscribe: () => {
        onMutexRelease();
    }
};
bleno_1.default.on("disconnect", () => {
    onMutexRelease();
});
mutexChar.addListener("PI_BRIDGE_MUTEX", mutexListener);
const waitForMutexToBeFinished = () => __awaiter(void 0, void 0, void 0, function* () {
    return new Promise((resolve, _reject) => {
        mutexReleaseSetupCallback = () => {
            resolve();
        };
    });
});
const waitForWifi = () => __awaiter(void 0, void 0, void 0, function* () {
    return new Promise((resolve, _reject) => {
        let interval;
        const checker = () => __awaiter(void 0, void 0, void 0, function* () {
            const status = yield piWifi.getStatus();
            logger.info(`Wifi status is not connected: ${status.ip}`);
            if (status.ip === "" || status.ip) {
                const inv = interval;
                if (inv) {
                    clearInterval(inv);
                }
                resolve();
            }
        });
        interval = setInterval(checker, 5000);
    });
});
const startBridge = (service) => __awaiter(void 0, void 0, void 0, function* () {
    archivistQueue.activeArchivists = yield archivistStore.restoreArchivists(defaultArchivists);
    yield Promise.all([waitForBleno()]);
    bleno_1.default.setServices([xyoService.service, service, adminService.service]);
    yield bridge.init();
    let notOnWifi = true;
    while (notOnWifi) {
        const status = yield piWifi.getStatus();
        logger.info(`Wifi status update: ${status.ip}`);
        if (status.ip === "" || status.ip === undefined) {
            inConfigureMode = true;
            logger.info(`Wifi status is not connected: ${status.ip}`);
            // not of wifi
            yield server.startAdvertising(adv.advertisementData(), adv.getScanResponse());
            yield waitForWifi();
            logger.info(`Done searching: ${status.ip}`);
        }
        logger.info(`On network: ${status.ip}`);
        if (hasMutex) {
            logger.info(`Waiting for mutex: ${status.ip}`);
            yield waitForMutexToBeFinished();
        }
        yield server.stopAdvertising();
        logger.info(`Mutex finished: ${status.ip}`);
        // on wifi
        inConfigureMode = false;
        notOnWifi = false;
        bridge.start();
    }
});
const waitForBleno = () => {
    bleno_1.default.enable();
    return new Promise((resolve, _reject) => {
        bleno_1.default.on('stateChange', (newState) => {
            if (newState == "poweredOn") {
                resolve();
            }
            else {
                logger.info(`Invalid state: ${newState}`);
                _reject();
            }
        });
    });
};
function main() {
    startPi();
}
exports.main = main;
//# sourceMappingURL=index.js.map