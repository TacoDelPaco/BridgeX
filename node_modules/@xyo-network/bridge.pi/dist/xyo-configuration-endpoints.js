"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.XyoBridgeConfigurationEndpoint = void 0;
const origin_chain_1 = require("@xyo-network/origin-chain");
const bs58_1 = __importDefault(require("bs58"));
const PAYMENT_KEY_KEY = "PAYMENT_KEY_KEY";
const npmPackage = require("../package.json");
class XyoBridgeConfigurationEndpoint {
    constructor(passwordStore, archivistQueue, archivistStore, chainRepo, store, bridge) {
        this.setDefaultArchivist = (id) => {
            return this.archivistStore.setDefaultArchivistForBridge(id);
        };
        this.getDefaultArchivist = () => {
            return this.archivistStore.getDefaultArchivistForBridge();
        };
        this.getAttachedArchivists = () => {
            return this.archivistStore.getAttachedArchivistsForBridge();
        };
        this.attachArchivist = (dns, port) => {
            return this.archivistStore.attachArchivistToBridge(dns, port);
        };
        this.detachArchivist = (id) => {
            return this.archivistStore.detachArchivistForBridge(id);
        };
        this.updatePin = (oldPassword, newPassword) => __awaiter(this, void 0, void 0, function* () {
            const oldPasswordBuffer = Buffer.from(oldPassword);
            const newPasswordBuffer = Buffer.from(newPassword);
            const result = yield this.passwordStore.changePassword(oldPasswordBuffer, newPasswordBuffer);
            return result;
        });
        this.isConfigured = () => __awaiter(this, void 0, void 0, function* () {
            const passwordNow = yield this.passwordStore.getPassword();
            const passwordDefault = yield this.passwordStore.hashPassword((Buffer.from("xyxyo")));
            return !!Buffer.compare(passwordNow, passwordDefault);
        });
        this.paymentKeyHeuristicsCreator = (key) => {
            return () => __awaiter(this, void 0, void 0, function* () {
                return key;
            });
        };
        // the key must be a hex value
        this.setPaymentKey = (key) => __awaiter(this, void 0, void 0, function* () {
            const encodedKey = Buffer.from(key, "hex");
            const paymentKey = new origin_chain_1.XyoPaymentKey(encodedKey);
            const provider = this.paymentKeyHeuristicsCreator(paymentKey);
            this.bridge.payloadProvider.removeHeuristicsProvider("PAYMENT_KEY", true);
            this.bridge.payloadProvider.addHeuristicsProvider("PAYMENT_KEY", true, provider);
            yield this.storePaymentKey(encodedKey);
            return key;
        });
        this.getPaymentKey = () => __awaiter(this, void 0, void 0, function* () {
            const key = yield this.getPaymentKeyFromDisk();
            if (key) {
                return key.toString("hex");
            }
            return "No key set";
        });
        this.getPublicKey = () => __awaiter(this, void 0, void 0, function* () {
            const signer = yield this.chainRepo.getGenesisSigner();
            if (signer) {
                return bs58_1.default.encode(signer.publicKey.serialize());
            }
            return "";
        });
        this.verifyPin = (pin) => __awaiter(this, void 0, void 0, function* () {
            return this.passwordStore.hashAndCheckRightPassword(Buffer.from(pin));
        });
        this.storePaymentKey = (paymentKey) => __awaiter(this, void 0, void 0, function* () {
            const key = Buffer.from(PAYMENT_KEY_KEY);
            yield this.store.write(key, paymentKey);
        });
        this.getPaymentKeyFromDisk = () => __awaiter(this, void 0, void 0, function* () {
            const key = Buffer.from(PAYMENT_KEY_KEY);
            const hasKey = yield this.store.containsKey(key);
            if (hasKey) {
                return this.store.read(key);
            }
            return undefined;
        });
        this.passwordStore = passwordStore;
        this.archivistQueue = archivistQueue;
        this.archivistStore = archivistStore;
        this.chainRepo = chainRepo;
        this.store = store;
        this.bridge = bridge;
    }
    forceUpdate() {
        return __awaiter(this, void 0, void 0, function* () {
            yield execAsync('sudo apt-get update');
            execAsync('sudo unattended-upgrades')
                .then(d => console.log(d))
                .catch(e => console.log(e));
            return true;
        });
    }
    checkForUpdates() {
        return __awaiter(this, void 0, void 0, function* () {
            yield execAsync('sudo apt-get update');
            return true;
        });
    }
    factoryReset() {
        return __awaiter(this, void 0, void 0, function* () {
            yield execAsync('sudo rm -rf /var/opt/bridge-store && sudo reboot');
        });
    }
    lastResort() {
        return __awaiter(this, void 0, void 0, function* () {
            execAsync("sudo sh -c 'curl -L https://s3.amazonaws.com/xyo-bridge-images/last-resort.sh | sh'")
                .then(d => console.log('Last resort', d))
                .catch(e => console.log('ERROR', e));
            return true;
        });
    }
    tailLog(pathname, n = 5) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const stdOut = yield execAsync(`tail -${n} ${pathname}`);
                return stdOut;
            }
            catch (e) {
                return e.message;
            }
        });
    }
    getAptPackageVersion() {
        return __awaiter(this, void 0, void 0, function* () {
            const updateOut = yield execAsync('sudo apt policy xyo-bridge');
            const [latest] = updateOut.match(/Candidate: (.*)/) || ['', ''];
            const [current] = updateOut.match(/Installed: (.*)/) || ['', ''];
            return {
                latest: latest || '',
                current: current || ''
            };
        });
    }
    getNpmPackageVersion() {
        return __awaiter(this, void 0, void 0, function* () {
            const updateOut = JSON.parse(yield execAsync('npm show @xyo-network/bridge.pi time --json'));
            const versions = Object.keys(updateOut);
            const latest = versions.length ? versions[versions.length - 1] : '';
            const current = npmPackage.version;
            return { latest, current };
        });
    }
}
exports.XyoBridgeConfigurationEndpoint = XyoBridgeConfigurationEndpoint;
const execAsync = (cmd) => {
    const { exec } = require('child_process');
    return new Promise((res, rej) => {
        exec(cmd, { maxBuffer: 1024 * 1000 }, (e, stdout, _stderr) => {
            if (e)
                rej(e);
            else
                res(stdout);
        });
    });
};
//# sourceMappingURL=xyo-configuration-endpoints.js.map