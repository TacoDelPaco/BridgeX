import bleno, { PrimaryService } from '@abandonware/bleno'
import noble from '@abandonware/noble'
import { NobleScan } from '@xyo-network/ble-central.noble'
import { IXyoMutableCharacteristicListener } from '@xyo-network/ble-peripheral'
import { BlenoCharacteristic, BlenoServer, BlenoService } from '@xyo-network/ble-peripheral.bleno'
import { IXyoBridgeConfig, XyoBridge } from '@xyo-network/bridge-core'
import { XyoStorageBridgeQueueRepository } from '@xyo-network/bridge-queue-repository.keyvalue'
import { getHashingProvider } from '@xyo-network/hashing'
import { XyoLogger } from '@xyo-network/logger'
import { XyoAdvertisement, XyoClientBluetoothNetwork, XyoFullBleNetwork, XyoServerNetwork } from '@xyo-network/network.ble'
import { IXyoTCPNetworkAddress, XyoClientTcpNetwork } from '@xyo-network/network.tcp'
import { XyoOriginBlockRepository } from '@xyo-network/origin-block-repository'
import { XyoOriginChainLocalStorageRepository } from '@xyo-network/origin-chain'
import { BridgeServer, IContext } from '@xyo-network/pi-bridge-server'
import { NetworkService } from '@xyo-network/pi-wifi-ble'
import { PiWifiManager } from '@xyo-network/pi-wifi-manager'
import { serializer } from '@xyo-network/serializer'
import { XyoLevelDbStorageProvider } from '@xyo-network/storage.leveldb'
import { XyoArchivistStore } from './xyo-archivist-store'
import { XyoBridgeArchivistQueue } from './xyo-bridge-archivist-queue'
import { XyoBridgeConfigurationEndpoint } from './xyo-configuration-endpoints'
import { XyoPasswordStore } from './xyo-password-store'

let hasMutex = false
let inConfigureMode = false

const nobleHandle = (enable: boolean) => {
  if (enable) {
    noble.enable()
  } else {
    noble.disable()
  }
}

const blenoHandle = (enable: boolean) => {
  if (enable) {
    bleno.enable()
  } else {
    bleno.disable()
  }
}

bleno.on('accept', (address) => {
  logger.info(`BLENO + accept event: ${ address }`)
})

bleno.on("advertisingStart", (err) => {
  logger.info(`BLENO + advertisingStart event: ${ err }`)
})

bleno.on("advertisingStartError", (err) => {
  logger.info(`BLENO + advertisingStartError event: ${ err }`)
})

bleno.on("advertisingStop", () => {
  logger.info(`BLENO + advertisingStop event`)
})

bleno.on("disconnect", (address) => {
  logger.info(`BLENO + disconnect event: ${ address }`)
})

bleno.on("mtuChange", (mtu) => {
  logger.info(`BLENO + mtuChange event: ${ mtu }`)
})

bleno.on("servicesSet", (err) => {
  logger.info(`BLENO + servicesSet event: ${ err }`)
})

bleno.on("servicesSetError", (err) => {
  logger.info(`BLENO + servicesSetError event: ${ err }`)
})

bleno.on("stateChange", (state) => {
  logger.info(`BLENO + stateChange event: ${ state }`)
})

noble.on("scanStart", () => {
  logger.info(`NOBLE + scanStart event`)
})

noble.on("scanStop", () => {
  logger.info(`NOBLE + scanStop event`)
})

noble.on("stateChange", (state) => {
  logger.info(`NOBLE + scanStop event: ${ state }`)
})

const hasher = getHashingProvider('sha256')
const char = new BlenoCharacteristic('727a36390eb44525b1bc7fa456490b2d', [ "write", "notify" ])
const xyoService = new BlenoService("d684352edf36484ebc982d5398c5593e", [ char ])
const mutexChar = new BlenoCharacteristic('e047295e3df047cda841be2d2a97dd21', [ "write", "notify" ])
const adminService = new BlenoService("c9be98507a57414ab79764c230d9ecb9", [ mutexChar ])

const server = new BlenoServer()
const bleServerNetwork = new XyoServerNetwork(char, server)
const scanner = new NobleScan()
const bleClientNetwork = new XyoClientBluetoothNetwork(scanner)
const fullBleNetwork = new XyoFullBleNetwork(bleClientNetwork, bleServerNetwork, nobleHandle, blenoHandle)
const storageProvider = new XyoLevelDbStorageProvider(process.env.STORE || "bridge-store", true)
const bridgeQueueRepo = new XyoStorageBridgeQueueRepository(storageProvider)
const blockRepo = new XyoOriginBlockRepository(storageProvider, serializer, hasher)
const chainRepo = new XyoOriginChainLocalStorageRepository(storageProvider, blockRepo, serializer)
const logger = new XyoLogger(false, false)
const archivistQueue = new XyoBridgeArchivistQueue()
const tcpClient = new XyoClientTcpNetwork(archivistQueue.tcpPeerSelector)
const passwordStore = new XyoPasswordStore(hasher, storageProvider)
const archivistStore = new XyoArchivistStore(archivistQueue, storageProvider)
const piWifi = new PiWifiManager()
const adv = new XyoAdvertisement(8)
let mutexReleaseSetupCallback: (() => void) | undefined = undefined

const defaultArchivists: IXyoTCPNetworkAddress[] = [
  {
    host: "alpha-peers.xyo.network",
    port: 11000
  }
]

const bridgeConfig: IXyoBridgeConfig = {
  hasher,
  storageProvider,
  bridgeQueueRepo,
  blockRepo,
  chainRepo,
  logger
}

const bridge = new XyoBridge(fullBleNetwork, tcpClient, bridgeConfig)

const startPi = async () => {
  const port = Number(process.env.PORT) || 13000
  
  
  const configuration = new XyoBridgeConfigurationEndpoint(
    passwordStore, 
    archivistQueue, 
    archivistStore, 
    chainRepo, 
    storageProvider, 
    bridge
  )

  const context: IContext = {
    port,
    wifi: piWifi,
    configuration: configuration
  }

  const server = new BridgeServer(context)
  const wifiService = new NetworkService(piWifi, configuration.verifyPin)

  server.start(() => {
    logger.info(`Server ready at http://localhost:${ port }`)
  })

  wifiService.start()
  startBridge(wifiService)
}

const onMutexHold = () => {
  logger.info("On mutex hold")

  if (!hasMutex) {
    if (inConfigureMode) {
      server.stopAdvertising()
    } else {
      bleServerNetwork.pause()
    }
    
    hasMutex = true
  }
}

/* Debugging noble warning: unknown handle x disconnected! */
const onMutexRelease = () => {
  logger.info("On mutex release")

  if (hasMutex) {
    logger.info("Has mutex")
    if (inConfigureMode) {
      logger.info("isConfiguredMode")
      server.startAdvertising(adv.advertisementData(), adv.getScanResponse())
      logger.info(adv.advertisementData() + " " + adv.getScanResponse())

      const callback = mutexReleaseSetupCallback
      if (callback) {
        logger.info("callback()")
        callback()
      }
    } else {
      logger.info("bleServerNetwork.unPause()")
      bleServerNetwork.unPause()
    }

    logger.info("hasMutex = false")
    hasMutex = false
  }
}

const mutexListener: IXyoMutableCharacteristicListener = {
  onSubscribe: () => {
    onMutexHold()
  },
  onUnsubscribe: () => {
    onMutexRelease()
  }
}

bleno.on("disconnect", () => {
  onMutexRelease()
})

mutexChar.addListener("PI_BRIDGE_MUTEX", mutexListener)

const waitForMutexToBeFinished = async () => {
  return new Promise((resolve) => {
    mutexReleaseSetupCallback = () => {
      resolve(undefined) // default ()
    }
  })
}

const waitForWifi = async () => {
  return new Promise((resolve) => {
    let interval: NodeJS.Timeout | undefined = undefined

    const checker = async () => {
      const status = await piWifi.getStatus()

      logger.info(`Wifi status is not connected: ${ status.ip }`)
  
      if (status.ip === "" || status.ip) { 
        const inv = interval
        if (inv) {
          clearInterval(inv)
        } 

        resolve(undefined) // default ()
      }
    }

    interval = setInterval(checker, 5_000)
  })
}


const startBridge = async (service: PrimaryService) => {
  archivistQueue.activeArchivists = await archivistStore.restoreArchivists(defaultArchivists)

  await Promise.all([ waitForBleno() ])
  bleno.setServices([ xyoService.service, service, adminService.service ])
  await bridge.init()
  
  let notOnWifi = true

  while (notOnWifi) {
    const status = await piWifi.getStatus()
    logger.info(`Wifi status update: ${ status.ip }`)
  
    if (status.ip === "" || status.ip === undefined) {
      inConfigureMode = true
      logger.info(`Wifi status is not connected: ${ status.ip }`)
      // not of wifi
      await server.startAdvertising(adv.advertisementData(), adv.getScanResponse())
      await waitForWifi()
      logger.info(`Done searching: ${ status.ip }`)
    }

    logger.info(`On network: ${ status.ip }`)

    if (hasMutex) {
      logger.info(`Waiting for mutex: ${ status.ip }`)
      await waitForMutexToBeFinished()
    }

    await server.stopAdvertising()

    logger.info(`Mutex finished: ${ status.ip }`)
   
    // on wifi
    inConfigureMode = false
    notOnWifi = false
    bridge.start()
  }
}

const waitForBleno = () => {
  bleno.enable()

  return new Promise((resolve, reject) => {
    bleno.on('stateChange', async (newState: string) => {
      if (newState == "poweredOn") {
        resolve(undefined) // default ()
      } else {
        logger.info(`Invalid state: ${ newState }`)
        reject()
      }
    })
  })
}

export function main() {
  startPi()
}
