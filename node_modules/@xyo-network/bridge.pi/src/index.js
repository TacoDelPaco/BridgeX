"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.main = void 0;
var pi_wifi_manager_1 = require("@xyo-network/pi-wifi-manager");
var pi_bridge_server_1 = require("@xyo-network/pi-bridge-server");
var logger_1 = require("@xyo-network/logger");
var origin_block_repository_1 = require("@xyo-network/origin-block-repository");
var origin_chain_1 = require("@xyo-network/origin-chain");
var serializer_1 = require("@xyo-network/serializer");
var ble_central_noble_1 = require("@xyo-network/ble-central.noble");
var network_ble_1 = require("@xyo-network/network.ble");
var bridge_queue_repository_keyvalue_1 = require("@xyo-network/bridge-queue-repository.keyvalue");
var storage_leveldb_1 = require("@xyo-network/storage.leveldb");
var hashing_1 = require("@xyo-network/hashing");
var network_tcp_1 = require("@xyo-network/network.tcp");
var bridge_core_1 = require("@xyo-network/bridge-core");
var ble_peripheral_bleno_1 = require("@xyo-network/ble-peripheral.bleno");
var xyo_bridge_archivist_queue_1 = require("./xyo-bridge-archivist-queue");
var xyo_configuration_endpoints_1 = require("./xyo-configuration-endpoints");
var xyo_password_store_1 = require("./xyo-password-store");
var xyo_archivist_store_1 = require("./xyo-archivist-store");
var pi_wifi_ble_1 = require("@xyo-network/pi-wifi-ble");
var bleno_1 = require("@abandonware/bleno");
var noble_1 = require("@abandonware/noble");
var hasMutex = false;
var inConfigureMode = false;
var nobleHandle = function (enable) {
    if (enable) {
        noble_1.default.enable();
    }
    else {
        noble_1.default.disable();
        noble_1.default.removeAllListeners;
    }
};
var blenoHandle = function (enable) {
    if (enable) {
        bleno_1.default.enable();
    }
    else {
        bleno_1.default.disable();
        bleno_1.default.removeAllListeners;
    }
};
bleno_1.default.on('accept', function (address) {
    logger.info("BLENO + accept event: ".concat(address));
});
bleno_1.default.on("advertisingStart", function (err) {
    logger.info("BLENO + advertisingStart event: ".concat(err));
});
bleno_1.default.on("advertisingStartError", function (err) {
    logger.info("BLENO + advertisingStartError event: ".concat(err));
});
bleno_1.default.on("advertisingStop", function () {
    logger.info("BLENO + advertisingStop event");
});
bleno_1.default.on("disconnect", function (address) {
    logger.info("BLENO + disconnect event: ".concat(address));
});
bleno_1.default.on("mtuChange", function (mtu) {
    logger.info("BLENO + mtuChange event: ".concat(mtu));
});
bleno_1.default.on("servicesSet", function (err) {
    logger.info("BLENO + servicesSet event: ".concat(err));
});
bleno_1.default.on("servicesSetError", function (err) {
    logger.info("BLENO + servicesSetError event: ".concat(err));
});
bleno_1.default.on("stateChange", function (state) {
    logger.info("BLENO + stateChange event: ".concat(state));
});
noble_1.default.on("scanStart", function () {
    logger.info("NOBLE + scanStart event");
});
noble_1.default.on("scanStop", function () {
    logger.info("NOBLE + scanStop event");
});
noble_1.default.on("stateChange", function (state) {
    logger.info("NOBLE + scanStop event: ".concat(state));
});
var hasher = (0, hashing_1.getHashingProvider)('sha256');
var char = new ble_peripheral_bleno_1.BlenoCharacteristic('727a36390eb44525b1bc7fa456490b2d', ["write", "notify"]);
var xyoService = new ble_peripheral_bleno_1.BlenoService("d684352edf36484ebc982d5398c5593e", [char]);
var mutexChar = new ble_peripheral_bleno_1.BlenoCharacteristic('e047295e3df047cda841be2d2a97dd21', ["write", "notify"]);
var adminService = new ble_peripheral_bleno_1.BlenoService("c9be98507a57414ab79764c230d9ecb9", [mutexChar]);
var server = new ble_peripheral_bleno_1.BlenoServer();
var bleServerNetwork = new network_ble_1.XyoServerNetwork(char, server);
var scanner = new ble_central_noble_1.NobleScan();
var bleClientNetwork = new network_ble_1.XyoClientBluetoothNetwork(scanner);
var fullBleNetwork = new network_ble_1.XyoFullBleNetwork(bleClientNetwork, bleServerNetwork, nobleHandle, blenoHandle);
var storageProvider = new storage_leveldb_1.XyoLevelDbStorageProvider(process.env.STORE || "bridge-store", true);
var bridgeQueueRepo = new bridge_queue_repository_keyvalue_1.XyoStorageBridgeQueueRepository(storageProvider);
var blockRepo = new origin_block_repository_1.XyoOriginBlockRepository(storageProvider, serializer_1.serializer, hasher);
var chainRepo = new origin_chain_1.XyoOriginChainLocalStorageRepository(storageProvider, blockRepo, serializer_1.serializer);
var logger = new logger_1.XyoLogger(false, false);
var archivistQueue = new xyo_bridge_archivist_queue_1.XyoBridgeArchivistQueue();
var tcpClient = new network_tcp_1.XyoClientTcpNetwork(archivistQueue.tcpPeerSelector);
var passwordStore = new xyo_password_store_1.XyoPasswordStore(hasher, storageProvider);
var archivistStore = new xyo_archivist_store_1.XyoArchivistStore(archivistQueue, storageProvider);
var piWifi = new pi_wifi_manager_1.PiWifiManager();
var adv = new network_ble_1.XyoAdvertisement(8);
var mutexReleaseSetupCallback = undefined;
var defaultArchivists = [
    {
        host: "alpha-peers.xyo.network",
        port: 11000
    }
];
var bridgeConfig = {
    hasher: hasher,
    storageProvider: storageProvider,
    bridgeQueueRepo: bridgeQueueRepo,
    blockRepo: blockRepo,
    chainRepo: chainRepo,
    logger: logger
};
var bridge = new bridge_core_1.XyoBridge(fullBleNetwork, tcpClient, bridgeConfig);
var startPi = function () { return __awaiter(void 0, void 0, void 0, function () {
    var port, configuration, context, server, wifiService;
    return __generator(this, function (_a) {
        port = Number(process.env.PORT) || 13000;
        configuration = new xyo_configuration_endpoints_1.XyoBridgeConfigurationEndpoint(passwordStore, archivistQueue, archivistStore, chainRepo, storageProvider, bridge);
        context = {
            port: port,
            wifi: piWifi,
            configuration: configuration
        };
        server = new pi_bridge_server_1.BridgeServer(context);
        wifiService = new pi_wifi_ble_1.NetworkService(piWifi, configuration.verifyPin);
        server.start(function () {
            logger.info("Server ready at http://localhost:".concat(port));
        });
        wifiService.start();
        startBridge(wifiService);
        return [2 /*return*/];
    });
}); };
var onMutexHold = function () {
    logger.info("On mutex hold");
    if (!hasMutex) {
        if (inConfigureMode) {
            server.stopAdvertising();
        }
        else {
            bleServerNetwork.pause();
        }
        hasMutex = true;
    }
};
/* Debugging noble warning: unknown handle x disconnected! */
var onMutexRelease = function () {
    logger.info("On mutex release");
    if (hasMutex) {
        logger.info("Has mutex");
        if (inConfigureMode) {
            logger.info("isConfiguredMode");
            server.startAdvertising(adv.advertisementData(), adv.getScanResponse());
            logger.info(adv.advertisementData() + " " + adv.getScanResponse());
            var callback = mutexReleaseSetupCallback;
            if (callback) {
                logger.info("callback()");
                callback();
            }
        }
        else {
            logger.info("bleServerNetwork.unPause()");
            bleServerNetwork.unPause();
        }
        logger.info("hasMutex = false");
        hasMutex = false;
    }
};
var mutexListener = {
    onSubscribe: function () {
        onMutexHold();
    },
    onUnsubscribe: function () {
        onMutexRelease();
    }
};
bleno_1.default.on("disconnect", function () {
    onMutexRelease();
});
mutexChar.addListener("PI_BRIDGE_MUTEX", mutexListener);
var waitForMutexToBeFinished = function () { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        return [2 /*return*/, new Promise(function (resolve, _reject) {
                mutexReleaseSetupCallback = function () {
                    resolve();
                };
            })];
    });
}); };
var waitForWifi = function () { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        return [2 /*return*/, new Promise(function (resolve, _reject) {
                var interval;
                var checker = function () { return __awaiter(void 0, void 0, void 0, function () {
                    var status, inv;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, piWifi.getStatus()];
                            case 1:
                                status = _a.sent();
                                logger.info("Wifi status is not connected: ".concat(status.ip));
                                if (status.ip === "" || status.ip) {
                                    inv = interval;
                                    if (inv) {
                                        clearInterval(inv);
                                    }
                                    resolve();
                                }
                                return [2 /*return*/];
                        }
                    });
                }); };
                interval = setInterval(checker, 5000);
            })];
    });
}); };
var startBridge = function (service) { return __awaiter(void 0, void 0, void 0, function () {
    var _a, notOnWifi, status_1;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0:
                _a = archivistQueue;
                return [4 /*yield*/, archivistStore.restoreArchivists(defaultArchivists)];
            case 1:
                _a.activeArchivists = _b.sent();
                return [4 /*yield*/, Promise.all([waitForBleno()])];
            case 2:
                _b.sent();
                bleno_1.default.setServices([xyoService.service, service, adminService.service]);
                return [4 /*yield*/, bridge.init()];
            case 3:
                _b.sent();
                notOnWifi = true;
                _b.label = 4;
            case 4:
                if (!notOnWifi) return [3 /*break*/, 12];
                return [4 /*yield*/, piWifi.getStatus()];
            case 5:
                status_1 = _b.sent();
                logger.info("Wifi status update: ".concat(status_1.ip));
                if (!(status_1.ip === "" || status_1.ip === undefined)) return [3 /*break*/, 8];
                inConfigureMode = true;
                logger.info("Wifi status is not connected: ".concat(status_1.ip));
                // not of wifi
                return [4 /*yield*/, server.startAdvertising(adv.advertisementData(), adv.getScanResponse())];
            case 6:
                // not of wifi
                _b.sent();
                return [4 /*yield*/, waitForWifi()];
            case 7:
                _b.sent();
                logger.info("Done searching: ".concat(status_1.ip));
                _b.label = 8;
            case 8:
                logger.info("On network: ".concat(status_1.ip));
                if (!hasMutex) return [3 /*break*/, 10];
                logger.info("Waiting for mutex: ".concat(status_1.ip));
                return [4 /*yield*/, waitForMutexToBeFinished()];
            case 9:
                _b.sent();
                _b.label = 10;
            case 10: return [4 /*yield*/, server.stopAdvertising()];
            case 11:
                _b.sent();
                logger.info("Mutex finished: ".concat(status_1.ip));
                // on wifi
                inConfigureMode = false;
                notOnWifi = false;
                bridge.start();
                return [3 /*break*/, 4];
            case 12: return [2 /*return*/];
        }
    });
}); };
var waitForBleno = function () {
    bleno_1.default.enable();
    return new Promise(function (resolve, _reject) {
        bleno_1.default.on('stateChange', function (newState) { return __awaiter(void 0, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (newState == "poweredOn") {
                    resolve();
                }
                else {
                    logger.info("Invalid state: ".concat(newState));
                }
                return [2 /*return*/];
            });
        }); });
    });
};
function main() {
    startPi();
}
exports.main = main;
//# sourceMappingURL=index.js.map