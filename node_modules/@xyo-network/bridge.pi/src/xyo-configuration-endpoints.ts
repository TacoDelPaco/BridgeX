import { IBridgeConfigurationManager, IArchivist } from '@xyo-network/bridge-configuration'
import { XyoPasswordStore } from './xyo-password-store'
import { IXyoStorageProvider } from '@xyo-network/storage'
import { IXyoSerializableObject } from '@xyo-network/serialization'
import { XyoBridgeArchivistQueue } from './xyo-bridge-archivist-queue'
import { XyoArchivistStore } from './xyo-archivist-store'
import { IXyoOriginChainRepository, XyoPaymentKey } from '@xyo-network/origin-chain'
import { XyoBridge } from '@xyo-network/bridge-core';
import bs58 from 'bs58'

const PAYMENT_KEY_KEY = "PAYMENT_KEY_KEY"
const npmPackage = require("../package.json")

export class XyoBridgeConfigurationEndpoint implements IBridgeConfigurationManager {
    passwordStore: XyoPasswordStore
    archivistQueue: XyoBridgeArchivistQueue
    archivistStore: XyoArchivistStore
    chainRepo: IXyoOriginChainRepository
    store: IXyoStorageProvider
    bridge: XyoBridge
    
    constructor(
        passwordStore: XyoPasswordStore,
        archivistQueue: XyoBridgeArchivistQueue,
        archivistStore: XyoArchivistStore,
        chainRepo: IXyoOriginChainRepository,
        store: IXyoStorageProvider,
        bridge: XyoBridge) {

        this.passwordStore = passwordStore
        this.archivistQueue = archivistQueue
        this.archivistStore = archivistStore
        this.chainRepo = chainRepo
        this.store = store
        this.bridge = bridge
    }

    public setDefaultArchivist = (id: string) => {
        return this.archivistStore.setDefaultArchivistForBridge(id)
    }

    public getDefaultArchivist = () => { 
        return this.archivistStore.getDefaultArchivistForBridge()
    }

    public getAttachedArchivists = () => { 
        return this.archivistStore.getAttachedArchivistsForBridge ()
    }

    public attachArchivist = (dns: string, port: number) => {
        return this.archivistStore.attachArchivistToBridge(dns, port)
    }

    public detachArchivist = (id: string) => { 
        return this.archivistStore.detachArchivistForBridge (id)
    }

    updatePin = async (oldPassword: string, newPassword: string): Promise<boolean> => {
        const oldPasswordBuffer = Buffer.from(oldPassword)
        const newPasswordBuffer = Buffer.from(newPassword)
        const result = await this.passwordStore.changePassword(oldPasswordBuffer, newPasswordBuffer)
      
        return result
      }
      
    isConfigured = async (): Promise<boolean> => {
        const passwordNow = await this.passwordStore.getPassword()
        const passwordDefault = await this.passwordStore.hashPassword((Buffer.from("xyxyo")))
        return !!Buffer.compare(passwordNow, passwordDefault)
    }
      
    paymentKeyHeuristicsCreator = (key: XyoPaymentKey): (() => Promise<IXyoSerializableObject>) => {
        return async () => {
          return key
        }
    }
      
    // the key must be a hex value
    setPaymentKey = async (key: string): Promise<string> => {
        const encodedKey = Buffer.from(key, "hex")
        const paymentKey = new XyoPaymentKey(encodedKey)
        const provider = this.paymentKeyHeuristicsCreator(paymentKey)
      
        this.bridge.payloadProvider.removeHeuristicsProvider("PAYMENT_KEY", true)
        this.bridge.payloadProvider.addHeuristicsProvider("PAYMENT_KEY", true, provider)
      
        await this.storePaymentKey(encodedKey)
      
        return key
      }
      
    getPaymentKey = async (): Promise<string> => {
        const key = await this.getPaymentKeyFromDisk()
      
        if (key) {
          return key.toString("hex")
        }
      
        return "No key set"
      }
      
    getPublicKey = async (): Promise<string> => {
        const signer = await this.chainRepo.getGenesisSigner()
      
        if (signer) {
          return bs58.encode(signer.publicKey.serialize())
        }
      
        return ""
      }
      
    verifyPin = async (pin: string): Promise<boolean> => {
        return this.passwordStore.hashAndCheckRightPassword(Buffer.from(pin))
    }
      
    storePaymentKey = async (paymentKey: Buffer) => {
        const key = Buffer.from(PAYMENT_KEY_KEY)
        await this.store.write(key, paymentKey)
    }
      
    getPaymentKeyFromDisk = async (): Promise<Buffer | undefined> => {
        const key = Buffer.from(PAYMENT_KEY_KEY)
        const hasKey = await this.store.containsKey(key)
      
        if (hasKey) {
          return this.store.read(key)
        }
      
        return undefined
      }

    async forceUpdate () {
        await execAsync('sudo apt-get update')
        execAsync('sudo unattended-upgrades')
        .then(d => console.log(d))
        .catch(e => console.log(e))
        return true       
    }

    async checkForUpdates () {
      await execAsync('sudo apt-get update')
      return true
    }

    public async factoryReset () {
      await execAsync('sudo rm -rf /var/opt/bridge-store && sudo reboot')
    }

    public async lastResort () {
        execAsync("sudo sh -c 'curl -L https://s3.amazonaws.com/xyo-bridge-images/last-resort.sh | sh'")
        .then(d => console.log('Last resort', d))
        .catch(e => console.log('ERROR', e))
        return true       
    }

    public async tailLog (pathname: string, n = 5) {
        try {
            const stdOut = await execAsync(`tail -${n} ${pathname}`)
            return stdOut
        } catch (e: any) {
            return e.message
        }
    }

    public async getAptPackageVersion () {
        const updateOut = await execAsync('sudo apt policy xyo-bridge')
        const [latest] = updateOut.match(/Candidate: (.*)/) || ['', '']
        const [current] = updateOut.match(/Installed: (.*)/) || ['', '']
        return {
            latest: latest || '',
            current: current || ''
        }
    }
        
    public async getNpmPackageVersion () {
        const updateOut = JSON.parse(await execAsync('npm show @xyo-network/bridge.pi time --json'))
        const versions = Object.keys(updateOut)
        const latest = versions.length ? versions[versions.length - 1] : ''
        const current = npmPackage.version
        return { latest, current }
    }
}

const execAsync = (cmd: string): Promise<string> => {
    const { exec } = require('child_process')
    return new Promise((res, rej) => {
      exec(cmd, { maxBuffer: 1024 * 1000 }, (e: Error|null, stdout: string, _stderr: string) => {
        if (e) rej(e)
        else res(stdout)
      })
    })
  }