"use strict";
/*
 * @Author: XY | The Findables Company <ryanxyo>
 * @Date:   Tuesday, 20th November 2018 2:04:50 pm
 * @Email:  developer@xyfindables.com
 * @Filename: xyo-ecdsa-secp256k1-signer-provider.ts
 * @Last modified by: ryanxyo
 * @Last modified time: Thursday, 7th March 2019 4:56:36 pm
 * @License: All Rights Reserved
 * @Copyright: Copyright XY | The Findables Company
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = require("@xyo-network/base");
const elliptic_1 = require("elliptic");
const xyo_ecdsa_secp256k1_signer_1 = require("./xyo-ecdsa-secp256k1-signer");
const ec = new elliptic_1.ec('secp256k1');
/**
 * A service for providing EcSecp256k signing services
 */
class XyoEcdsaSecp256k1SignerProvider extends base_1.XyoBase {
    /**
     * Creates an instance of XyoEcdsaSecp256k1SignerProvider.
     * If a HashProvider is provided, that data will be hashed before being signed
     *
     * @param {IXyoHashProvider} [hashProvider] An optional HashProvider
     * @memberof XyoEcdsaSecp256k1SignerProvider
     */
    constructor(hashProvider, ecdsaSecp256k1UnCompressedPublicKeyObjectSchemaId, ecdsaSecp256k1SignatureObjectSchemaId) {
        super();
        this.hashProvider = hashProvider;
        this.ecdsaSecp256k1UnCompressedPublicKeyObjectSchemaId = ecdsaSecp256k1UnCompressedPublicKeyObjectSchemaId;
        this.ecdsaSecp256k1SignatureObjectSchemaId = ecdsaSecp256k1SignatureObjectSchemaId;
    }
    /**
     * Returns a new instance of a signer
     */
    newInstance(fromHexKey) {
        let key;
        if (fromHexKey) {
            const privateKey = ec.keyFromPrivate(fromHexKey, 'hex');
            const correspondingPublicKey = privateKey.getPublic();
            privateKey._importPublic(correspondingPublicKey);
            key = privateKey;
        }
        else {
            key = ec.genKeyPair();
        }
        return new xyo_ecdsa_secp256k1_signer_1.XyoEcdsaSecp256k1Signer(this.verifySign.bind(this), this.getSignFn(key), () => {
            const publicKey = key.getPublic();
            return {
                x: publicKey.x.toBuffer(),
                y: publicKey.y.toBuffer(),
            };
        }, () => {
            return key.getPrivate('hex');
        }, this.ecdsaSecp256k1UnCompressedPublicKeyObjectSchemaId, this.ecdsaSecp256k1SignatureObjectSchemaId);
    }
    /**
     * Verifies a a signature given the data that was signed, and a public key
     *
     * @param signature The signature to verify
     * @param data The data that was signed
     * @param publicKey The corresponding publicKey of public cryptography key-pair
     */
    verifySign(signature, data, publicKey) {
        return __awaiter(this, void 0, void 0, function* () {
            const dataToSign = yield this.getDataToSign(data);
            const uncompressedEcPublicKey = publicKey;
            const x = uncompressedEcPublicKey.x.toString('hex');
            const y = uncompressedEcPublicKey.y.toString('hex');
            const hexKey = ['04', x, y].join('');
            const key = ec.keyFromPublic(hexKey, 'hex');
            return key.verify(dataToSign, this.buildDER(signature.encodedSignature));
        });
    }
    getSignFn(key) {
        return (data) => __awaiter(this, void 0, void 0, function* () {
            const dataToSign = yield this.getDataToSign(data);
            const signature = key.sign(dataToSign);
            const rBuffer = signature.r.toBuffer();
            const sBuffer = signature.s.toBuffer();
            return Buffer.concat([
                Buffer.from([rBuffer.length]),
                rBuffer,
                Buffer.from([sBuffer.length]),
                sBuffer
            ]);
        });
    }
    getDataToSign(data) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.hashProvider) {
                return data;
            }
            const hashedData = yield this.hashProvider.createHash(data);
            return hashedData.getHash();
        });
    }
    buildDER(xyBuffer) {
        const sizeOfR = xyBuffer.readUInt8(0);
        const rBuffer = xyBuffer.slice(1, sizeOfR + 1);
        const source = Buffer.concat([
            Buffer.from([0x02]),
            xyBuffer.slice(0, 1),
            rBuffer,
            Buffer.from([0x02]),
            xyBuffer.slice(sizeOfR + 1),
        ]);
        const sourceBufferSizeBuffer = Buffer.alloc(1);
        sourceBufferSizeBuffer.writeUInt8(source.length, 0);
        return new Uint8Array(Buffer.concat([
            Buffer.from([0x30]),
            sourceBufferSizeBuffer,
            source
        ]));
    }
}
exports.XyoEcdsaSecp256k1SignerProvider = XyoEcdsaSecp256k1SignerProvider;
//# sourceMappingURL=xyo-ecdsa-secp256k1-signer-provider.js.map