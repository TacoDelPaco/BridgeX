"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.XyoBridge = void 0;
const bound_witness_1 = require("@xyo-network/bound-witness");
const bridge_queue_repository_1 = require("@xyo-network/bridge-queue-repository");
const network_1 = require("@xyo-network/network");
const peer_connections_1 = require("@xyo-network/peer-connections");
const peer_interaction_1 = require("@xyo-network/peer-interaction");
const peer_interaction_handlers_1 = require("@xyo-network/peer-interaction-handlers");
const peer_interaction_router_1 = require("@xyo-network/peer-interaction-router");
const serializer_1 = require("@xyo-network/serializer");
const signing_ecdsa_1 = require("@xyo-network/signing.ecdsa");
const xyo_bridge_bound_witness_success_listener_1 = require("./xyo-bridge-bound-witness-success-listener");
const xyo_bridge_procedure_catalogue_1 = require("./xyo-bridge-procedure-catalogue");
class XyoBridge {
    constructor(bridgeFromNetwork, bridgeToNetwork, bridgeConfig) {
        this.bridgeConfig = bridgeConfig;
        this.bridgeEveryN = 3;
        this.bridgeQueue = new bridge_queue_repository_1.XyoBridgeQueue(this.bridgeConfig.bridgeQueueRepo);
        this.bridgeOption = new bridge_queue_repository_1.XyoBridgeOption(this.bridgeConfig.blockRepo, this.bridgeQueue, this.bridgeConfig.hasher);
        this.payloadProvider = new peer_interaction_1.XyoBoundWitnessPayloadProvider();
        this.running = false;
        this.networkCatResolver = {
            resolveCategory: (catalogueItems) => {
                for (const item of catalogueItems) {
                    if (item === network_1.CatalogueItem.GIVE_ORIGIN_CHAIN) {
                        return network_1.CatalogueItem.TAKE_ORIGIN_CHAIN;
                    }
                }
                for (const item of catalogueItems) {
                    if (item === network_1.CatalogueItem.TAKE_ORIGIN_CHAIN) {
                        return network_1.CatalogueItem.GIVE_ORIGIN_CHAIN;
                    }
                }
                return network_1.CatalogueItem.BOUND_WITNESS;
            }
        };
        this.networkRouter = new peer_interaction_router_1.XyoPeerInteractionRouter();
        this.boundWitnessValidator = new bound_witness_1.XyoBoundWitnessValidator();
        this.networkHandler = new peer_connections_1.XyoPeerConnectionHandler(this.networkRouter, this.networkCatResolver);
        this.success = new xyo_bridge_bound_witness_success_listener_1.XyoBridgeBoundWitnessSuccessListener(this.bridgeConfig.hasher, this.boundWitnessValidator, this.bridgeConfig.chainRepo, this.bridgeConfig.blockRepo, this.bridgeQueue, this.bridgeOption);
        this.interactionFactoryRegular = {
            newInstance: (signersForBoundWitness, payload) => {
                return new peer_interaction_handlers_1.XyoBoundWitnessInteraction(signersForBoundWitness, payload, serializer_1.serializer, network_1.CatalogueItem.BOUND_WITNESS);
            }
        };
        this.interactionFactoryGive = {
            newInstance: (signersForBoundWitness, payload) => {
                return new peer_interaction_handlers_1.XyoBoundWitnessInteraction(signersForBoundWitness, payload, serializer_1.serializer, network_1.CatalogueItem.GIVE_ORIGIN_CHAIN);
            }
        };
        this.interactionFactoryTake = {
            newInstance: (signersForBoundWitness, payload) => {
                return new peer_interaction_handlers_1.XyoBoundWitnessInteraction(signersForBoundWitness, payload, serializer_1.serializer, network_1.CatalogueItem.TAKE_ORIGIN_CHAIN);
            }
        };
        this.standardBoundWitnessHandlerProviderRegular = new peer_interaction_1.XyoBoundWitnessHandlerProvider(this.bridgeConfig.chainRepo, this.payloadProvider, this.success, this.interactionFactoryRegular);
        this.standardBoundWitnessHandlerProviderTake = new peer_interaction_1.XyoBoundWitnessHandlerProvider(this.bridgeConfig.chainRepo, this.payloadProvider, this.success, this.interactionFactoryTake);
        this.standardBoundWitnessHandlerProviderGive = new peer_interaction_1.XyoBoundWitnessHandlerProvider(this.bridgeConfig.chainRepo, this.payloadProvider, this.success, this.interactionFactoryGive);
        this.mainBridgeLoop = () => __awaiter(this, void 0, void 0, function* () {
            this.bridgeConfig.logger.info(`Bridge on new cycle`);
            try {
                const blePipe = yield this.networkDelegate.provideConnection();
                yield this.networkDelegate.handlePeerConnection(blePipe);
                if ((yield this.bridgeConfig.chainRepo.getIndex()) % this.bridgeEveryN === 0) {
                    this.bridgeConfig.logger.info("Will try to bridge blocks");
                    const tcpPipe = yield this.toNetworkDelegate.provideConnection();
                    yield this.toNetworkDelegate.handlePeerConnection(tcpPipe);
                    yield tcpPipe.close();
                    const blocksToRemove = this.bridgeQueue.getBlocksToRemove();
                    for (const block of blocksToRemove) {
                        yield this.bridgeConfig.blockRepo.removeOriginBlock(block);
                    }
                    yield this.bridgeConfig.bridgeQueueRepo.commit();
                }
            }
            catch (error) {
                this.bridgeConfig.logger.error(`Uncaught error: ${error}\n${error.stack}\n${error.cause}`);
            }
            this.bridgeConfig.logger.info(`Bridge has block height: ${yield this.bridgeConfig.chainRepo.getIndex()}`);
        });
        const bridgeProcedureCatalogueCollect = new xyo_bridge_procedure_catalogue_1.XyoBrideProcedureCatalogue([
            network_1.CatalogueItem.GIVE_ORIGIN_CHAIN,
            network_1.CatalogueItem.TAKE_ORIGIN_CHAIN,
            network_1.CatalogueItem.BOUND_WITNESS
        ]);
        const bridgeProcedureCatalogueSend = new xyo_bridge_procedure_catalogue_1.XyoBrideProcedureCatalogue([
            network_1.CatalogueItem.GIVE_ORIGIN_CHAIN,
            network_1.CatalogueItem.TAKE_ORIGIN_CHAIN,
        ]);
        this.networkDelegate = new peer_connections_1.XyoSimplePeerConnectionDelegate(bridgeFromNetwork, bridgeProcedureCatalogueCollect, this.networkHandler);
        this.toNetworkDelegate = new peer_connections_1.XyoSimplePeerConnectionDelegate(bridgeToNetwork, bridgeProcedureCatalogueSend, this.networkHandler);
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            this.payloadProvider.addBoundWitnessOption(network_1.CatalogueItem.TAKE_ORIGIN_CHAIN, this.bridgeOption);
            this.networkRouter.use(network_1.CatalogueItem.BOUND_WITNESS, () => {
                return this.standardBoundWitnessHandlerProviderRegular;
            });
            this.networkRouter.use(network_1.CatalogueItem.TAKE_ORIGIN_CHAIN, () => {
                return this.standardBoundWitnessHandlerProviderTake;
            });
            this.networkRouter.use(network_1.CatalogueItem.GIVE_ORIGIN_CHAIN, () => {
                return this.standardBoundWitnessHandlerProviderGive;
            });
            yield this.bridgeConfig.bridgeQueueRepo.restore();
            if ((yield this.bridgeConfig.chainRepo.getIndex()) === 0) {
                const newSigner = (0, signing_ecdsa_1.getSignerProvider)("secp256k1-sha256").newInstance();
                this.bridgeConfig.logger
                    .info(`Creating first signer, has public key: ${newSigner.publicKey.getData().toString('hex')}`);
                yield this.bridgeConfig.chainRepo.setCurrentSigners([newSigner]);
                const boundWitness = yield this.bridgeConfig.chainRepo.createGenesisBlock();
                yield this.success.onBoundWitnessSuccess(boundWitness, undefined, network_1.CatalogueItem.BOUND_WITNESS);
                yield this.bridgeConfig.bridgeQueueRepo.commit();
            }
        });
    }
    start() {
        this.running = true;
        this.asyncLoop();
    }
    stop() {
        this.running = false;
    }
    asyncLoop() {
        return __awaiter(this, void 0, void 0, function* () {
            while (this.running) {
                yield this.mainBridgeLoop();
            }
        });
    }
}
exports.XyoBridge = XyoBridge;
//# sourceMappingURL=xyo-bridge.js.map