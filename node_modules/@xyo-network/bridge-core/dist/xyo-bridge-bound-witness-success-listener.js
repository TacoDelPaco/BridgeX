"use strict";
/*
* @Author: XY | The Findables Company <ryanxyo>
* @Date:   Thursday, 7th February 2019 11:32:52 am
* @Email:  developer@xyfindables.com
* @Filename: xyo-bound-witness-success-listener.ts
* @Last modified by: ryanxyo
* @Last modified time: Thursday, 7th February 2019 11:33:33 am
* @License: All Rights Reserved
* @Copyright: Copyright XY | The Findables Company
*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.XyoBridgeBoundWitnessSuccessListener = void 0;
const base_1 = require("@xyo-network/base");
const bound_witness_1 = require("@xyo-network/bound-witness");
const network_1 = require("@xyo-network/network");
const origin_chain_1 = require("@xyo-network/origin-chain");
const peer_interaction_1 = require("@xyo-network/peer-interaction");
class XyoBridgeBoundWitnessSuccessListener extends base_1.XyoBase {
    constructor(hashingProvider, boundWitnessValidator, originChainRepository, originBlockRepository, bridgeQueue, bridgeOption) {
        super();
        this.hashingProvider = hashingProvider;
        this.boundWitnessValidator = boundWitnessValidator;
        this.originChainRepository = originChainRepository;
        this.originBlockRepository = originBlockRepository;
        this.bridgeQueue = bridgeQueue;
        this.bridgeOption = bridgeOption;
    }
    onBoundWitnessSuccess(boundWitness, mutex, choice) {
        return __awaiter(this, void 0, void 0, function* () {
            const hashValue = yield this.hashingProvider.createHash(boundWitness.getSigningData());
            try {
                yield this.boundWitnessValidator.validateBoundWitness(hashValue, boundWitness);
            }
            catch (err) {
                this.logError(`Origin block failed validation. Will not add.`, err);
                throw err;
            }
            this.bridgeQueue.addQueueItem(hashValue.serialize());
            const removedSubItemsBlock = this.removeSubBoundWitnesses(boundWitness);
            yield this.originBlockRepository.addOriginBlock(hashValue, removedSubItemsBlock);
            yield this.boundWitnessValidator.validateBoundWitness(hashValue, boundWitness);
            yield this.originChainRepository.updateOriginChainState(hashValue, removedSubItemsBlock, mutex);
            this.logInfo(`${hashValue.serializeHex()} added to Origin-Chain and Origin-Block-Repository`);
            const nestedBoundWitnesses = new peer_interaction_1.XyoNestedBoundWitnessExtractor().extractNestedBoundWitnesses(boundWitness);
            yield nestedBoundWitnesses.reduce((promiseChain, nestedBoundWitness) => __awaiter(this, void 0, void 0, function* () {
                yield promiseChain;
                const nestedHashValue = yield this.hashingProvider.createHash(nestedBoundWitness.getSigningData());
                const nestedHash = nestedHashValue.serialize();
                this.logInfo(`Extracted nested block with hash ${nestedHash.toString('hex')}`);
                const containsBlock = yield this.originBlockRepository.containsOriginBlock(nestedHash);
                if (!containsBlock) {
                    try {
                        this.bridgeQueue.addQueueItem(nestedHash);
                        yield this.boundWitnessValidator.validateBoundWitness(nestedHashValue, nestedBoundWitness);
                    }
                    catch (err) {
                        this.logError(`Origin block failed validation. Will not add.`, err);
                        throw err;
                    }
                    yield this.originBlockRepository.addOriginBlock(nestedHashValue, nestedBoundWitness, hashValue);
                }
            }), Promise.resolve());
            if (choice === network_1.CatalogueItem.TAKE_ORIGIN_CHAIN) {
                this.bridgeOption.onCompleted();
            }
            return;
        });
    }
    removeSubBoundWitnesses(boundWitness) {
        // tslint:disable-next-line:prefer-array-literal
        const newBoundWitnessArray = [];
        boundWitness.fetterWitnesses.forEach((fOW) => {
            if (fOW instanceof bound_witness_1.XyoWitness) {
                const newItems = [];
                const array = fOW.getData();
                array.forEach((item) => {
                    if (item.schemaObjectId !== origin_chain_1.XyoBridgeBlockSet.deserializer.schemaObjectId &&
                        item.schemaObjectId !== bound_witness_1.XyoSignatureSet.deserializer.schemaObjectId) {
                        newItems.push(item);
                    }
                });
                newBoundWitnessArray.push(new bound_witness_1.XyoWitness(fOW.signatureSet, newItems));
            }
            else if (fOW instanceof bound_witness_1.XyoFetter) {
                newBoundWitnessArray.push(fOW);
            }
            else {
                newBoundWitnessArray.push(fOW);
            }
        });
        return new bound_witness_1.XyoBoundWitness(newBoundWitnessArray);
    }
}
exports.XyoBridgeBoundWitnessSuccessListener = XyoBridgeBoundWitnessSuccessListener;
//# sourceMappingURL=xyo-bridge-bound-witness-success-listener.js.map