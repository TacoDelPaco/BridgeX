"use strict";
/*
 * @Author: XY | The Findables Company <ryanxyo>
 * @Date:   Wednesday, 28th November 2018 5:51:34 pm
 * @Email:  developer@xyfindables.com
 * @Filename: parse.ts
 * @Last modified by: ryanxyo
 * @Last modified time: Wednesday, 12th December 2018 1:23:50 pm
 * @License: All Rights Reserved
 * @Copyright: Copyright XY | The Findables Company
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.parse = void 0;
const readHeader_1 = require("./readHeader");
const sliceItem_1 = require("./sliceItem");
function parse(src, schema) {
    const partialSchema = (0, readHeader_1.readHeader)(src);
    const data = (0, sliceItem_1.sliceItem)(src, 0, partialSchema, true);
    const headerBytes = src.subarray(0, 2 + partialSchema.sizeIdentifierSize);
    if (partialSchema.iterableType === 'not-iterable') {
        return {
            data,
            headerBytes,
            id: partialSchema.id,
            sizeIdentifierSize: partialSchema.sizeIdentifierSize,
            dataBytes: data,
            iterableType: 'not-iterable'
        };
    }
    if (data.length === 0) {
        return {
            headerBytes,
            data: [],
            id: partialSchema.id,
            sizeIdentifierSize: partialSchema.sizeIdentifierSize,
            iterableType: 'not-iterable',
            dataBytes: data
        };
    }
    const items = [];
    let innerHeader = (0, readHeader_1.readHeader)(data);
    let innerHeaderBytes = data.subarray(0, 2);
    let offset = 2;
    let sizeBytes = data.subarray(offset, offset + innerHeader.sizeIdentifierSize);
    while (offset < data.length) {
        if (partialSchema.iterableType === 'iterable-untyped') {
            if (offset !== 2) {
                innerHeaderBytes = data.subarray(offset, offset + 2);
                innerHeader = (0, readHeader_1.readHeader)(innerHeaderBytes);
                offset += 2;
            }
        }
        if (offset !== 2) {
            sizeBytes = data.subarray(offset, offset + innerHeader.sizeIdentifierSize);
        }
        const bytes = (0, sliceItem_1.sliceItem)(data, offset, innerHeader, false);
        offset += bytes.length + innerHeader.sizeIdentifierSize;
        if (innerHeader.iterableType !== 'not-iterable') {
            items.push(parse(Buffer.concat([innerHeaderBytes, sizeBytes, bytes]), schema));
        }
        else {
            items.push({
                id: innerHeader.id,
                sizeIdentifierSize: innerHeader.sizeIdentifierSize,
                iterableType: innerHeader.iterableType,
                data: bytes,
                dataBytes: bytes,
                headerBytes: Buffer.concat([innerHeaderBytes, sizeBytes])
            });
        }
    }
    return {
        headerBytes,
        data: items,
        id: partialSchema.id,
        sizeIdentifierSize: partialSchema.sizeIdentifierSize,
        iterableType: partialSchema.iterableType,
        dataBytes: data
    };
}
exports.parse = parse;
//# sourceMappingURL=parse.js.map