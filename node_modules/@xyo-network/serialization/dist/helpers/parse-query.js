"use strict";
/*
 * @Author: XY | The Findables Company <ryanxyo>
 * @Date:   Wednesday, 28th November 2018 5:52:23 pm
 * @Email:  developer@xyfindables.com
 * @Filename: parse-query.ts
 * @Last modified by: ryanxyo
 * @Last modified time: Wednesday, 6th March 2019 4:42:51 pm
 * @License: All Rights Reserved
 * @Copyright: Copyright XY | The Findables Company
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ParseQuery = void 0;
const errors_1 = require("@xyo-network/errors");
class ParseQuery {
    constructor(parseResult) {
        this.parseResult = parseResult;
    }
    query(queryIndexes) {
        const queriedParseResult = queryIndexes.reduce((parseResult, indexToQuery, indexInArray) => {
            if (Array.isArray(parseResult.data)) {
                const childParseResults = parseResult.data;
                if (childParseResults.length > indexToQuery) {
                    return childParseResults[indexToQuery];
                }
                throw new errors_1.XyoError(`Data can not be queried. Index out of bounds ${indexInArray}`);
            }
            throw new errors_1.XyoError(`Data can not be queried at index ${indexInArray}`);
        }, this.parseResult);
        return new ParseQuery(queriedParseResult);
    }
    mapChildren(callbackfn) {
        if (this.isReadable()) {
            throw new errors_1.XyoError(`No children to map`);
        }
        return this.parseResult.data.map((item, index) => {
            return callbackfn(new ParseQuery(item), index);
        });
    }
    getChildAt(index) {
        if (this.isReadable()) {
            throw new errors_1.XyoError(`No children to map`);
        }
        if (index > this.parseResult.data.length) {
            throw new errors_1.XyoError(`Index out of range`);
        }
        return new ParseQuery(this.parseResult.data[index]);
    }
    reduceChildren(reducer, startingValue) {
        if (this.isReadable()) {
            throw new errors_1.XyoError(`No children to map`);
        }
        return this.parseResult.data.reduce(reducer, startingValue);
    }
    getChildrenCount() {
        if (this.parseResult.data instanceof Buffer) {
            return -1;
        }
        return this.parseResult.data.length;
    }
    readData(withHeader = false) {
        if (!withHeader) {
            return this.parseResult.dataBytes;
        }
        return Buffer.concat([
            this.parseResult.headerBytes,
            this.parseResult.dataBytes,
        ]);
    }
    isReadable() {
        return this.parseResult.data instanceof Buffer;
    }
}
exports.ParseQuery = ParseQuery;
//# sourceMappingURL=parse-query.js.map