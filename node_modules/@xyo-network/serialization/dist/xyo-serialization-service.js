"use strict";
/*
 * @Author: XY | The Findables Company <ryanxyo>
 * @Date:   Tuesday, 20th November 2018 5:51:48 pm
 * @Email:  developer@xyfindables.com
 * @Filename: xyo-serialization-service.ts
 * @Last modified by: ryanxyo
 * @Last modified time: Wednesday, 6th March 2019 4:42:51 pm
 * @License: All Rights Reserved
 * @Copyright: Copyright XY | The Findables Company
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.XyoSerializationService = void 0;
const base_1 = require("@xyo-network/base");
const errors_1 = require("@xyo-network/errors");
const on_the_fly_serializable_1 = require("./helpers/on-the-fly-serializable");
const parse_1 = require("./helpers/parse");
const readHeader_1 = require("./helpers/readHeader");
const resolveSerializablesToBuffer_1 = require("./helpers/resolveSerializablesToBuffer");
const serialize_1 = require("./helpers/serialize");
const tree_iterator_1 = require("./helpers/tree-iterator");
const xyo_filler_1 = require("./xyo-filler");
class XyoSerializationService extends base_1.XyoBase {
    constructor(schema) {
        super();
        this.schema = schema;
        this.recipes = {};
    }
    serialize(serializable, serializationType) {
        const result = serializable.serialize();
        const buf = result instanceof Buffer ?
            result :
            (0, resolveSerializablesToBuffer_1.resolveSerializablesToBuffer)(serializable.realSchema(), this.schema, result);
        const b = (0, serialize_1.serialize)(buf, serializable.realSchema());
        if (serializationType === 'hex') {
            return b.toString('hex');
        }
        return b;
    }
    addDeserializer(deserializer) {
        if (Boolean(this.recipes[deserializer.schemaObjectId])) {
            throw new errors_1.XyoError(`There already exist a deserializer for ${deserializer.schemaObjectId}`);
        }
        this.recipes[deserializer.schemaObjectId] = deserializer;
    }
    deserialize(deserializable) {
        const src = deserializable instanceof Buffer ? deserializable : Buffer.from(deserializable, 'hex');
        const parseResult = this.parse(src);
        const schemaKey = Object.keys(this.schema).find(key => this.schema[key].id === parseResult.id);
        return new tree_iterator_1.XyoTreeIterator(this, parseResult, schemaKey || 'unknown', src);
    }
    parse(src) {
        return (0, parse_1.parse)(src, this.schema);
    }
    hydrate(deserializable) {
        const src = Buffer.concat([
            deserializable.headerBytes,
            deserializable.dataBytes
        ]);
        const srcSchema = (0, readHeader_1.readHeader)(src);
        const recipe = this.recipes[srcSchema.id];
        // this happens when there is a type we do not know about
        if (!recipe) {
            return new xyo_filler_1.XyoFiller(this.schema, src);
        }
        const deserializationResult = recipe.deserialize(src, this);
        deserializationResult.srcBuffer = src;
        deserializationResult.origin = src;
        return deserializationResult;
    }
    arrayOf(tCollection) {
        const typeAccumulator = {};
        // tslint:disable-next-line:prefer-for-of
        for (let i = 0; i < tCollection.length; i++) {
            typeAccumulator[tCollection[i].schemaObjectId] = (typeAccumulator[tCollection[i].schemaObjectId] || 0) + 1;
            if (Object.keys(typeAccumulator).length > 1) {
                return this.untypedArrayOf(tCollection);
            }
        }
        return this.typedArrayOf(tCollection);
    }
    typedArrayOf(tCollection) {
        const options = {};
        if (tCollection.length === 0) {
            options.buffer = Buffer.alloc(0);
        }
        else {
            options.array = tCollection;
        }
        return new on_the_fly_serializable_1.XyoOnTheFlySerializable(this.schema, this.schema.typedSet.id, options, 'typedSet', tCollection);
    }
    untypedArrayOf(tCollection) {
        const options = {};
        if (tCollection.length === 0) {
            options.buffer = Buffer.alloc(0);
        }
        else {
            options.array = tCollection;
        }
        return new on_the_fly_serializable_1.XyoOnTheFlySerializable(this.schema, this.schema.untypedSet.id, options, 'untypedSet', tCollection);
    }
    findFirstElement(collection, schemaObjectId) {
        return collection.find(item => item.schemaObjectId === schemaObjectId);
    }
}
exports.XyoSerializationService = XyoSerializationService;
//# sourceMappingURL=xyo-serialization-service.js.map