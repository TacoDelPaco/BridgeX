/* eslint-disable @typescript-eslint/no-var-requires */
/* eslint-disable @typescript-eslint/no-explicit-any */
import { Subscribe } from '@xyo-network/utils'
import debug from 'debug'
import { get } from 'lodash'
import { IConnect, INetwork, IStatus, IWifiManager } from '../@types'
import { getIp } from '../utils'

export default class PiWifiManager extends Subscribe<IStatus> implements IWifiManager {
  public statusInterval = 10_000
  private intervalId: any
  private updating = false
  private logger = debug('wifi:pi')
  private wifi = new (require('rpi-wifi-connection') as any)()
  public async getStatus(): Promise<IStatus> {
    const status = await this.wifi.getStatus('wlan0')
    const ssid = get(status, 'ssid')
    const ip = get(status, 'ip') || get(status, 'ip_address') || getIp()
    return { ssid, ip }
  }
  public async connect({ ssid, password }: IConnect): Promise<undefined> {
    return this.wifi.connect({ ssid, psk: password })
  }
  public async getNetworks(): Promise<INetwork[]> {
    const networks = await this.wifi.getNetworks()
    return networks || []
  }
  public async disconnect(): Promise<boolean> {
    const { ssid } = await this.getStatus()
    if (!ssid) return false
    const networks = await this.getNetworks()
    for (const network of networks) {
      await this.wifi.wpa_cli(`remove_network ${ network.id }`, '^OK')
    }
    return true
  }
  public async scan(): Promise<IStatus[]> {
    return this.wifi.scan()
  }
  public subscribe(fn: (d: IStatus) => void) {
    const unsubscribe = super.subscribe(fn)
    if (this.listenerCount() === 1) {
      this.startStatusListener()
    }
    return () => {
      unsubscribe()
      if (!this.hasSubscribers()) {
        this.stopStatusListener()
      }
    }
  }
  private startStatusListener() {
    this.stopStatusListener()
    this.intervalId = setInterval(this.updateStatus, this.statusInterval)
    this.updateStatus()
  }
  private stopStatusListener() {
    clearInterval(this.intervalId)
  }
  private updateStatus = async () => {
    if (this.updating) {
      this.logger('status update in progress')
      return
    }
    try {
      const status = await this.getStatus()
      this.setCurrentValue(status)
    } catch (e: any) {
      this.logger('status update error', e.message)
    }
  }
}
