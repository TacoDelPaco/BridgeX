"use strict";
/*
 * @Author: XY | The Findables Company <ryanxyo>
 * @Date:   Wednesday, 26th September 2018 3:01:22 pm
 * @Email:  developer@xyfindables.com
 * @Filename: xyo-client-tcp-network.ts
 * @Last modified by: ryanxyo
 * @Last modified time: Wednesday, 6th March 2019 2:56:16 pm
 * @License: All Rights Reserved
 * @Copyright: Copyright XY | The Findables Company
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.XyoClientTcpNetwork = void 0;
const net_1 = __importDefault(require("net"));
const xyo_tcp_connection_result_1 = require("./xyo-tcp-connection-result");
const base_1 = require("@xyo-network/base");
const xyo_tcp_network_pipe_1 = require("./xyo-tcp-network-pipe");
/**
 * This is not a production-ready TCP client. It was built to test the TCP server.
 * At any rate, it does reliably meet the tcp client functionality.
 */
class XyoClientTcpNetwork extends base_1.XyoBase {
    /**
     * Creates an instance of XyoClientTcpNetwork.
     *
     * @param {IXyoNetworkAddressProvider} networkAddressProvider Used to discover servers to try gain connections to
     * @memberof XyoClientTcpNetwork
     */
    constructor(networkAddressProvider) {
        super();
        this.networkAddressProvider = networkAddressProvider;
        /** True if looping, false otherwise */
        this.isLooping = false;
    }
    /**
     * Attempts to find tcp-network servers compatible with `catalogue` passed in
     *
     * @param {IXyoNetworkProcedureCatalogue} catalogue A catalogue of items the consumer can perform
     *
     * @returns {Promise<IXyoNetworkPipe>} The promise will be resolve once a network-pipe is created, which may be never
     * @memberof XyoClientTcpNetwork
     */
    find(catalogue) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logInfo(`Attempting to find peers`);
            // Start looping and resolve promise once a network pipe is created
            return new Promise((resolve, reject) => {
                this.loop(catalogue, resolve, reject);
            });
        });
    }
    /** Stops the client-tcp-network from trying to find peers */
    stopServer() {
        if (!this.isLooping) {
            return Promise.resolve();
        }
        return new Promise((resolve) => {
            if (!this.isLooping) {
                return resolve();
            }
            // Set shouldStopPromise so that when the run-loops sees this and calls it
            this.shouldStopPromise = () => {
                this.shouldStopPromise = undefined; // unset
                resolve();
            };
        });
    }
    /** The primary looping function the client-tcp-network performs to try to find a peer */
    loop(catalogue, resolve, reject) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logInfo(`Run loop entered`);
            if (this.shouldStopPromise) { // If shouldStopPromise is set, exit loop
                this.logInfo(`Run loop will end`);
                this.isLooping = false;
                reject(); // reject, could not find peer
                this.shouldStopPromise();
                return;
            }
            this.logInfo(`Will try to find next address`);
            const nextAddress = yield this.networkAddressProvider.next(); // get next networkAddress to try
            if (!nextAddress) { // If no networkWork address is available, pause for 1sec, then loop again
                base_1.XyoBase.timeout(() => {
                    this.loop(catalogue, resolve, reject);
                }, 1000);
                return;
            }
            try {
                // Try to get connection, will throw an error if it does not succeed
                const connectionResult = yield this.getConnection(nextAddress, catalogue);
                return resolve(new xyo_tcp_network_pipe_1.XyoTcpNetworkPipe(connectionResult));
            }
            catch (err) {
                this.logError(`There was an error creating client connection`, err);
                // Take 1sec break an try again
                base_1.XyoBase.timeout(() => {
                    this.loop(catalogue, resolve, reject);
                }, 5000);
                return;
            }
        });
    }
    /** Try to establish a connection for a given networkAddress */
    getConnection(nextAddress, catalogue) {
        return __awaiter(this, void 0, void 0, function* () {
            console.log(catalogue);
            const client = net_1.default.createConnection(nextAddress.port, nextAddress.host, () => {
                this.logInfo(`Client Connection made with ${nextAddress.host}:${nextAddress.port}`);
            });
            const onError = (err) => {
                this.logError(`An error occurred while getting connection`, err);
            };
            // const onConnect
            client.on('error', onError);
            // client.on('connect')
            return new xyo_tcp_connection_result_1.XyoTcpConnectionResult(client, undefined);
        });
    }
}
exports.XyoClientTcpNetwork = XyoClientTcpNetwork;
//# sourceMappingURL=xyo-client-tcp-network.js.map