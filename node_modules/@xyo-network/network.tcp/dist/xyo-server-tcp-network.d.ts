import { IXyoNetworkProvider, IXyoNetworkProcedureCatalogue, IXyoNetworkPipe } from '@xyo-network/network';
import { XyoBase } from '@xyo-network/base';
/**
 * A network provider build on top of the TCP/IP stack.
 * This implementation may seem peculiar because there is a
 * great deal of effort to ensure that there is never more than
 * one `meaningful` connection made to a peer.
 */
export declare class XyoServerTcpNetwork extends XyoBase implements IXyoNetworkProvider {
    port?: number | undefined;
    /**
     * An ephemeral short lived server for making connection to peers
     */
    private server;
    /**
     * Represents the current connection to a peer
     */
    private connection;
    private disconnectTimeout;
    /**
     * Creates an instance of a XyoServerTcpNetwork
     *
     * @param port The port to bind to for incoming network requests
     */
    constructor(port?: number | undefined);
    setPort(port: number): void;
    /**
     * Will attempt to locate peers. Once a peer is found the server will close
     * and not accept any more incoming connections.
     *
     * @param catalogue A peer-matchmaking delegate
     */
    find(catalogue: IXyoNetworkProcedureCatalogue): Promise<IXyoNetworkPipe>;
    /**
     * Will stop the existing server so that it doesn't service any more
     * incoming connections. Importantly, existing connections can continue
     * to communicate. This promise returned by this function will one
     * resolve once all connections have ended.
     */
    stopServer(): Promise<void>;
    /**
     * Builds a `XyoTcpConnectionResult` once was is available
     *
     * @param server The server that is being listened on
     * @param _catalogue The peer-matchmaking catalogue
     */
    private getConnection;
    private cancelDisconnect;
    private scheduleDisconnect;
}
//# sourceMappingURL=xyo-server-tcp-network.d.ts.map