"use strict";
/*
 * @Author: XY | The Findables Company <ryanxyo>
 * @Date:   Thursday, 13th September 2018 11:40:42 am
 * @Email:  developer@xyfindables.com
 * @Filename: xyo-tcp-network-pipe.ts
 * @Last modified by: ryanxyo
 * @Last modified time: Wednesday, 6th March 2019 4:42:51 pm
 * @License: All Rights Reserved
 * @Copyright: Copyright XY | The Findables Company
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.XyoTcpNetworkPipe = void 0;
const errors_1 = require("@xyo-network/errors");
const base_1 = require("@xyo-network/base");
/**
 * A communication pipe using tcp/ip stack
 */
class XyoTcpNetworkPipe extends base_1.XyoBase {
    /**
     * Creates an instance of a XyoTcpNetworkPipe
     *
     * @param connectionResult The resulting connection from the initial tcp/ip exchange
     */
    constructor(connectionResult) {
        super();
        this.connectionResult = connectionResult;
        this.networkHeuristics = [];
        /**
         * Any initiationData that may have been passed with the first part of the connection
         */
        this.initiationData = this.connectionResult.initiationData;
        /**
         * Returns the peer from the other end of the pipe
         */
        this.peer = {
            getTemporaryPeerId: () => {
                return this.connectionResult.socketId;
            }
        };
    }
    /**
     * This allows a consumer to register a listener when a peer disconnects
     *
     * @param callback Will be called with `hasError` equal to true if an error occurred
     */
    onPeerDisconnect(callback) {
        this.connectionResult.socket.on('close', callback);
        return () => {
            this.connectionResult.socket.removeListener('close', callback);
        };
    }
    /**
     * Sends a message to a peer
     * @param message The message to send
     * @param awaitResponse If true, the promised being returned by this function will only resolve
     *                      once the other party sends a message back.
     * @returns Returns the message back from the other party wrapped in a promise. Will return `undefined`
     *          if no response is available
     */
    send(message, awaitResponse) {
        const networkMessage = this.padBufferWithSize(message);
        this.connectionResult.socket.write(networkMessage);
        if (typeof awaitResponse === 'boolean' && !awaitResponse) {
            return Promise.resolve(undefined);
        }
        return new Promise((resolve, reject) => {
            let timeout;
            const listener = this.onSendOnDataFn((data) => {
                if (timeout)
                    timeout();
                timeout = undefined;
                return resolve(data);
            }, (err) => {
                if (timeout)
                    timeout();
                timeout = undefined;
                reject(err);
            });
            timeout = base_1.XyoBase.timeout(() => __awaiter(this, void 0, void 0, function* () {
                this.connectionResult.socket.removeListener('data', listener);
                yield this.close();
                reject(new errors_1.XyoError('Connection timed out after sending message'));
            }), 3000);
            this.connectionResult.socket.on('data', listener);
        });
    }
    /**
     * Closes the connection to the peer
     */
    close() {
        this.connectionResult.socket.end();
        this.connectionResult.socket.destroy();
        return Promise.resolve(undefined);
    }
    /**
     * A helper function to add a size header to the buffer
     */
    padBufferWithSize(b) {
        const sizeBuffer = Buffer.alloc(4);
        sizeBuffer.writeUInt32BE(b.length + 4, 0);
        return Buffer.concat([sizeBuffer, b]);
    }
    /**
     * Returns a function that chunks data and resolves once a tcp message is chunked according
     * to the size provided in the tcp message header
     *
     * @param resolve A resolve function to be called once finished. Will resolve with the message as the first parameter.
     * @param reject A reject function if an error occurs
     */
    onSendOnDataFn(resolve, reject) {
        let data;
        let sizeOfPayload;
        const onSendOnData = (chunk) => {
            if (data === undefined) {
                if (chunk.length < 4) {
                    this.connectionResult.socket.end();
                    return reject(new errors_1.XyoError(`Corrupt payload`));
                }
                sizeOfPayload = chunk.readUInt32BE(0);
            }
            data = Buffer.concat([
                data || Buffer.alloc(0),
                chunk
            ]);
            if (sizeOfPayload === data.length) {
                this.connectionResult.socket.removeListener('data', onSendOnData);
                return resolve(data.subarray(4));
            }
        };
        return onSendOnData;
    }
}
exports.XyoTcpNetworkPipe = XyoTcpNetworkPipe;
//# sourceMappingURL=xyo-tcp-network-pipe.js.map