"use strict";
/*
 * @Author: XY | The Findables Company <ryanxyo>
 * @Date:   Thursday, 6th September 2018 12:49:41 pm
 * @Email:  developer@xyfindables.com
 * @Filename: xyo-tcp-network.ts
 * @Last modified by: ryanxyo
 * @Last modified time: Wednesday, 6th March 2019 3:02:54 pm
 * @License: All Rights Reserved
 * @Copyright: Copyright XY | The Findables Company
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.XyoServerTcpNetwork = void 0;
const xyo_tcp_connection_result_1 = require("./xyo-tcp-connection-result");
const xyo_tcp_network_pipe_1 = require("./xyo-tcp-network-pipe");
const base_1 = require("@xyo-network/base");
const net_1 = __importDefault(require("net"));
/**
 * A network provider build on top of the TCP/IP stack.
 * This implementation may seem peculiar because there is a
 * great deal of effort to ensure that there is never more than
 * one `meaningful` connection made to a peer.
 */
class XyoServerTcpNetwork extends base_1.XyoBase {
    /**
     * Creates an instance of a XyoServerTcpNetwork
     *
     * @param port The port to bind to for incoming network requests
     */
    constructor(port) {
        super();
        this.port = port;
    }
    setPort(port) {
        this.port = port;
    }
    /**
     * Will attempt to locate peers. Once a peer is found the server will close
     * and not accept any more incoming connections.
     *
     * @param catalogue A peer-matchmaking delegate
     */
    find(catalogue) {
        return __awaiter(this, void 0, void 0, function* () {
            /** Create a server and listen on port */
            this.server = net_1.default.createServer();
            this.server.listen(this.port, '0.0.0.0');
            /** Wait for a single XYO connection */
            const connectionResult = yield this.getConnection(this.server, catalogue);
            /** Close the server to new connections while this one is handled */
            this.server.close();
            /** Clears state so this tcp-network instance can be used again */
            const onConnectionClose = () => {
                connectionResult.socket.removeListener('close', onConnectionClose);
                connectionResult.socket.removeListener('error', onConnectionError);
                this.connection = undefined;
            };
            const onConnectionError = (err) => {
                this.logInfo(`An error occurred on an open TCP connection`, err);
                this.connection = undefined;
            };
            connectionResult.socket.on('close', onConnectionClose);
            connectionResult.socket.on('error', onConnectionError);
            return new xyo_tcp_network_pipe_1.XyoTcpNetworkPipe(connectionResult);
        });
    }
    /**
     * Will stop the existing server so that it doesn't service any more
     * incoming connections. Importantly, existing connections can continue
     * to communicate. This promise returned by this function will one
     * resolve once all connections have ended.
     */
    stopServer() {
        if (this.server) {
            return new Promise((resolve, reject) => {
                if (this.server) {
                    this.server.close((err) => {
                        if (err) {
                            return reject(err);
                        }
                        return resolve();
                    });
                }
                return resolve();
            });
        }
        return Promise.resolve();
    }
    /**
     * Builds a `XyoTcpConnectionResult` once was is available
     *
     * @param server The server that is being listened on
     * @param _catalogue The peer-matchmaking catalogue
     */
    getConnection(server, catalogue) {
        console.log(catalogue);
        return new Promise((resolve) => {
            const onConnection = (c) => {
                this.logInfo(`Server Connection made with ${c.remoteAddress || 'unknown ip'}`);
                if (this.connection) { // Prevents multiple connections
                    this.logInfo(`Connection already exists, will close incoming connection`);
                    c.end();
                    return;
                }
                this.connection = c;
                this.scheduleDisconnect(c);
                const onConnectionClose = (hasError) => {
                    console.log(hasError);
                    this.cancelDisconnect();
                    this.connection = undefined;
                };
                const onError = (err) => {
                    this.logError(`An error error getting a connection`, err);
                    this.cancelDisconnect();
                    this.connection = undefined;
                };
                c.on('close', onConnectionClose);
                c.on('error', onError);
                let data;
                let sizeOfPayload;
                const onData = (chunk) => {
                    this.scheduleDisconnect(c);
                    data = Buffer.concat([
                        data || Buffer.alloc(0),
                        chunk
                    ]);
                    if (data.length < 4) {
                        return;
                    }
                    if (sizeOfPayload === undefined) {
                        sizeOfPayload = data.readUInt32BE(0);
                        this.logInfo(`Expecting message of size ${sizeOfPayload}`);
                    }
                    if (data.length > sizeOfPayload) { // too many, corrupt payload
                        this.logInfo(`Hanging up, payload too big ${data.length}`);
                        this.connection = undefined;
                        this.cancelDisconnect();
                        c.destroy(); // destroy because this might be an attack
                        return;
                    }
                    if (sizeOfPayload === data.length) {
                        this.cancelDisconnect();
                        c.removeListener('data', onData);
                        c.removeListener('close', onConnectionClose);
                        c.removeListener('error', onError);
                        server.removeListener('connection', onConnection);
                        this.connection = undefined;
                        // chop of the size that the client sent
                        const dataReceivedWithoutSize = data.subarray(4);
                        console.log(dataReceivedWithoutSize);
                        const tcpConnectResult = new xyo_tcp_connection_result_1.XyoTcpConnectionResult(c, dataReceivedWithoutSize);
                        return resolve(tcpConnectResult);
                    }
                };
                c.on('data', onData);
            };
            server.on('connection', onConnection);
        });
    }
    cancelDisconnect() {
        if (this.disconnectTimeout) {
            this.disconnectTimeout();
            this.disconnectTimeout = undefined;
        }
    }
    scheduleDisconnect(c) {
        this.cancelDisconnect();
        this.disconnectTimeout = base_1.XyoBase.timeout(() => {
            this.logInfo(`Connection timed out while negotiating`);
            this.connection = undefined;
            c.end();
        }, 3000);
    }
}
exports.XyoServerTcpNetwork = XyoServerTcpNetwork;
//# sourceMappingURL=xyo-server-tcp-network.js.map