"use strict";
/*
 * @Author: XY | The Findables Company <ryanxyo>
 * @Date:   Tuesday, 20th November 2018 3:24:51 pm
 * @Email:  developer@xyfindables.com
 * @Filename: index.ts
 * @Last modified by: ryanxyo
 * @Last modified time: Thursday, 13th December 2018 10:45:58 am
 * @License: All Rights Reserved
 * @Copyright: Copyright XY | The Findables Company
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.XyoRsaPublicKey = exports.rsaWithSha256SignatureDeserializer = exports.getSignerProvider = exports.XyoRsaShaSigner = void 0;
const xyo_rsa_sha_signer_provider_1 = require("./xyo-rsa-sha-signer-provider");
const errors_1 = require("@xyo-network/errors");
const serialization_schema_1 = require("@xyo-network/serialization-schema");
const rsa_signature_1 = require("./rsa-signature");
const xyo_rsa_sha_signer_1 = require("./xyo-rsa-sha-signer");
var xyo_rsa_sha_signer_2 = require("./xyo-rsa-sha-signer");
Object.defineProperty(exports, "XyoRsaShaSigner", { enumerable: true, get: function () { return xyo_rsa_sha_signer_2.XyoRsaShaSigner; } });
const signerProviderCache = {};
/**
 * Gets an instance of a `XyoRsaShaSignerProvider` signer provider
 *
 * @export
 * @param {SignerProviderType} signerProviderType
 * @returns {XyoRsaShaSignerProvider}
 */
function getSignerProvider(signerProviderType) {
    if (signerProviderCache[signerProviderType]) {
        return signerProviderCache[signerProviderType];
    }
    let signerProvider;
    switch (signerProviderType) {
        case 'rsa-sha256':
            signerProvider = new xyo_rsa_sha_signer_provider_1.XyoRsaShaSignerProvider("pkcs1-sha256", serialization_schema_1.schema.rsaWithSha256Signature.id);
            break;
        default:
            throw new errors_1.XyoError(`Could not resolve signer provider type ${signerProviderType}`, errors_1.XyoErrors.INVALID_PARAMETERS);
    }
    return signerProvider;
}
exports.getSignerProvider = getSignerProvider;
class XyoRsaWithSha256Signature {
    constructor() {
        this.schemaObjectId = serialization_schema_1.schema.rsaWithSha256Signature.id;
    }
    deserialize(data, serializationService) {
        const parseResult = serializationService.parse(data);
        const signerProvider = getSignerProvider('rsa-sha256');
        return new rsa_signature_1.XyoRsaSignature(parseResult.data, signerProvider.verifySign.bind(signerProvider), this.schemaObjectId);
    }
}
exports.rsaWithSha256SignatureDeserializer = new XyoRsaWithSha256Signature();
var xyo_rsa_public_key_1 = require("./xyo-rsa-public-key");
Object.defineProperty(exports, "XyoRsaPublicKey", { enumerable: true, get: function () { return xyo_rsa_public_key_1.XyoRsaPublicKey; } });
// tslint:disable-next-line:max-classes-per-file
class XyoRsaShaSignerDeserializer {
    constructor() {
        this.schemaObjectId = serialization_schema_1.schema.rsaSigner.id;
    }
    deserialize(data, serializationService) {
        const parseResult = serializationService.parse(data);
        const signer = getSignerProvider('rsa-sha256');
        return signer.newInstance(parseResult.dataBytes.toString());
    }
}
xyo_rsa_sha_signer_1.XyoRsaShaSigner.deserializer = new XyoRsaShaSignerDeserializer();
//# sourceMappingURL=index.js.map