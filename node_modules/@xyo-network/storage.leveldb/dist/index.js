"use strict";
/*
 * @Author: XY | The Findables Company <ryanxyo>
 * @Date:   Thursday, 13th December 2018 9:34:47 am
 * @Email:  developer@xyfindables.com
 * @Filename: index.ts
 * @Last modified by: ryanxyo
 * @Last modified time: Friday, 8th March 2019 3:54:44 pm
 * @License: All Rights Reserved
 * @Copyright: Copyright XY | The Findables Company
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.XyoLevelDbStorageProvider = void 0;
const levelup_1 = __importDefault(require("levelup"));
const leveldown_1 = __importDefault(require("leveldown"));
class XyoLevelDbStorageProvider {
    static createStore(location) {
        return getLevelDbStore(location);
    }
    constructor(levelDbDirectory, syncWrite) {
        this.syncWrite = false;
        if (syncWrite) {
            this.syncWrite = syncWrite;
        }
        this.levelDbDirectory = levelDbDirectory;
        this.db = (0, levelup_1.default)((0, leveldown_1.default)(this.levelDbDirectory));
    }
    write(key, value) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                if (this.db) {
                    this.db.put(key, value, { sync: this.syncWrite }, (err) => {
                        if (err) {
                            return reject(err);
                        }
                        return resolve(undefined);
                    });
                }
                else {
                    return reject("no db");
                }
            });
        });
    }
    read(key) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                if (this.db) {
                    this.db.get(key, (err, value) => {
                        if (err) {
                            return reject(err);
                        }
                        return resolve(value);
                    });
                }
                else {
                    return reject("no db");
                }
            });
        });
    }
    getAllKeys() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                if (this.db) {
                    const keys = [];
                    this.db.createKeyStream()
                        .on('data', (data) => {
                        keys.push(data);
                    })
                        .on('end', () => {
                        return resolve(keys);
                    });
                }
                else {
                    return reject("no db");
                }
            });
        });
    }
    delete(key) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                if (this.db) {
                    this.db.del(key, (err) => {
                        if (err) {
                            return reject(err);
                        }
                        return resolve(undefined);
                    });
                }
                else {
                    return reject("no db");
                }
            });
        });
    }
    containsKey(key) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const value = yield this.read(key);
                return Boolean(value);
            }
            catch (err) {
                if (err.notFound) {
                    return false;
                }
                throw err;
            }
        });
    }
    iterate(options) {
        const readOptions = {};
        if (options && options.offsetKey) {
            readOptions.gt = options.offsetKey;
        }
        if (options && options.limit) {
            readOptions.limit = options.limit + 1; // We add 1 so we can answer the question has next :-)
        }
        return new Promise((resolve, reject) => {
            const values = [];
            let promiseResolved = false;
            if (this.db) {
                this.db.createReadStream(readOptions)
                    .on('data', (data) => {
                    values.push(data);
                })
                    .on('error', (err) => {
                    if (!promiseResolved) {
                        promiseResolved = true;
                        reject(err);
                    }
                })
                    .on('close', () => {
                    if (!promiseResolved) {
                        promiseResolved = true;
                        const hasMoreItems = options.limit ? values.length === options.limit + 1 : false;
                        if (hasMoreItems) {
                            values.pop();
                        }
                        resolve({
                            hasMoreItems,
                            items: values
                        });
                    }
                })
                    .on('end', () => {
                    if (!promiseResolved) {
                        promiseResolved = true;
                        const hasMoreItems = options.limit ? values.length === options.limit + 1 : false;
                        if (hasMoreItems) {
                            values.pop();
                        }
                        resolve({
                            hasMoreItems,
                            items: values
                        });
                    }
                });
            }
            else {
                reject("no db");
            }
        });
    }
}
exports.XyoLevelDbStorageProvider = XyoLevelDbStorageProvider;
const cache = {};
function getLevelDbStore(storeLocation) {
    return __awaiter(this, void 0, void 0, function* () {
        const store = cache[storeLocation];
        if (store) {
            return store;
        }
        const newStore = new XyoLevelDbStorageProvider(storeLocation);
        cache[storeLocation] = newStore;
        return newStore;
    });
}
//# sourceMappingURL=index.js.map