import { XyoBase } from '@xyo-network/base'
import { IXyoScan } from "@xyo-network/ble-central"
import { XyoLogger } from '@xyo-network/logger'
import { IXyoNetworkPipe, IXyoNetworkProcedureCatalogue, IXyoNetworkProvider } from '@xyo-network/network'
import { XyoNearbyDevices } from './devices/xyo-nearby-devices'
import { XyoPipeClient } from './devices/xyo-pipe-client'

export class XyoClientBluetoothNetwork implements IXyoNetworkProvider {
  private scanner: IXyoScan
  private tryingDevice = false
  private nearbyDevices: XyoPipeClient[] = []
  private scanInterval: NodeJS.Timeout | undefined
  private nearby = new XyoNearbyDevices()
  private onPipe: ((pipe: IXyoNetworkPipe) => void) | undefined
  private onClose: (() => void) | undefined

  public logger: XyoLogger = new XyoLogger(false, false)

  constructor(scanner: IXyoScan) {
    this.scanner = scanner
  }

  private scanLambda = async () => {
    const nearbyNow = this.scanner.getDevices()
    this.nearbyDevices = this.nearby.nearby(nearbyNow)

    if (!this.tryingDevice && this.nearbyDevices.length > 0) {
      const randomDevice = this.nearbyDevices[Math.floor(Math.random() * this.nearbyDevices.length)]
      this.tryingDevice = true

      await this.scanner.stopScan()
      randomDevice.tryCreatePipe().then(async (createdPipe) => {
        if (this.scanInterval) {
          clearInterval(this.scanInterval)
        }

        if (createdPipe) {
          this.resolveCallback(createdPipe)
        } else {
          const callback = this.onClose
          if (callback) {
            return callback()
          }

          await this.scanner.startScan()
          this.tryingDevice = false
        }
      }).catch(async (_e) => {
        const callback = this.onClose
        this.logger.info(`Error: ${_e}`)
        if (callback) {
          return callback()
        }

        await this.scanner.startScan()

        this.tryingDevice = false
      })
    }
  }

  private resolveCallback(pipe: IXyoNetworkPipe) {
    const callback = this.onPipe

    if (callback) {
      callback(pipe)
    }
  }

  private async shutDown() {
    const interval = this.scanInterval

    if (interval) {
      clearInterval(interval)
      this.scanInterval = undefined
    }

    this.onPipe = undefined
    this.onClose = undefined
    await this.scanner.stopScan()
  }

  private async waitForJobToFinish() {
    return new Promise<void>((resolve, _reject) => {
      this.onClose = () => {
        resolve()
      }
    })
  }

  public findWithTimeout(timeoutInMills: number): Promise<IXyoNetworkPipe | undefined> {
    this.tryingDevice = false

    return new Promise((resolve, _reject) => {
      this.scanner.startScan().then(() => {
        var hasResumed = false
        const onTimeout = async () => {
          if (!hasResumed) {
            if (this.tryingDevice) {
              await this.waitForJobToFinish()
            }

            await this.shutDown()
            resolve(undefined)
          }
        }

        XyoBase.timeout(onTimeout, timeoutInMills)

        this.onPipe = async (pipe: IXyoNetworkPipe) => {
          hasResumed = true
          await this.shutDown()
          resolve(pipe)
        }

        this.scanInterval = setInterval(this.scanLambda, 1_000)
      }).catch((_e) => {
        this.logger.info(`Error: ${_e}`)
        resolve(undefined)
      })
    })
  }

  public find(_catalogue: IXyoNetworkProcedureCatalogue): Promise<IXyoNetworkPipe> {
    this.tryingDevice = false
    
    return new Promise(async (resolve, _reject) => {
      await this.scanner.startScan()

      this.onPipe = (pipe: IXyoNetworkPipe) => {
        this.shutDown()
        resolve(pipe)
      }

      this.scanInterval = setInterval(this.scanLambda, 1_000)
    })
  }

  public stopServer(): Promise<void> {
    return this.scanner.stopScan()
  }
}
