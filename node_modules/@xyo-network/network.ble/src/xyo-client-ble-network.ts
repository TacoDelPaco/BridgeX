import { XyoBase } from '@xyo-network/base'
import { IXyoScan } from "@xyo-network/ble-central"
import { XyoLogger } from '@xyo-network/logger'
import { IXyoNetworkPipe, IXyoNetworkProcedureCatalogue, IXyoNetworkProvider } from '@xyo-network/network'
import { XyoNearbyDevices } from './devices/xyo-nearby-devices'
import { XyoPipeClient } from './devices/xyo-pipe-client'

export class XyoClientBluetoothNetwork implements IXyoNetworkProvider {
  private nearby = new XyoNearbyDevices()
  private nearbyDevices: XyoPipeClient[] = []
  private onClose: (() => void) | undefined = undefined
  private onPipe: ((pipe: IXyoNetworkPipe) => void) | undefined = undefined
  private scanInterval: NodeJS.Timeout | undefined = undefined
  private scanner: IXyoScan
  private tryingDevice = false

  public logger: XyoLogger = new XyoLogger(false, false)

  constructor (scanner: IXyoScan) {
    this.scanner = scanner
  }

  private scanLambda = async () => {
    this.logger.info(`XyoClientBluetoothNetwork.scanLambda()`)
    const nearbyNow = this.scanner.getDevices()
    this.nearbyDevices = this.nearby.nearby(nearbyNow)

    if (!this.tryingDevice && this.nearbyDevices.length > 0) {
      const randomDevice = this.nearbyDevices[ Math.floor(Math.random() * this.nearbyDevices.length) ]
      this.tryingDevice = true
      // Running twice? shutDown() gets called after
      this.logger.info(`XyoClientBluetoothNetwork.scanLambda(): stopScan()`)
      await this.scanner.stopScan()

      randomDevice.tryCreatePipe().then(async (createdPipe) => {
        this.logger.info(`XyoClientBluetoothNetwork.scanLambda().randomDevice.tryCreatePipe()`)
        if (this.scanInterval) clearInterval(this.scanInterval)

        if (createdPipe) {
          this.resolveCallback(createdPipe) // default no await
          this.logger.info(`XyoClientBluetoothNetwork.tryCreatePipe.resolveCallback()`)
        } else {
          const callback = this.onClose
          if (callback) {
            callback()
            return
          }

          this.logger.info(`XyoClientBluetoothNetwork.tryCreatePipe.else{ startScan() }`)
          await this.scanner.startScan()
          this.tryingDevice = false
        }
      }).catch(async (error) => {
        const callback = this.onClose
        if (callback) {
          callback()
          return
        }

        this.logger.error(`XyoClientBluetoothNetwork.tryCreatePipe.catch(): ${ error }`)
        await this.scanner.startScan()
        this.tryingDevice = false
      })
    }
  }

  private resolveCallback(pipe: IXyoNetworkPipe) {
    const callback = this.onPipe
    this.logger.info(`XyoClientBluetoothNetwork.resolveCallback()`)
    if (callback) callback(pipe) // return pipe / callback(pipe)
  }

  private async shutDown() {
    const interval = this.scanInterval

    if (interval) {
      clearInterval(interval)
      this.scanInterval = undefined
    }

    this.onPipe = undefined
    this.onClose = undefined
    this.logger.info(`XyoClientBluetoothNetwork().shutDown(): stopScan()`)
    await this.scanner.stopScan() // await breaks loop or timeout without
  }

  // default no async/await
  private waitForJobToFinish() {
    this.logger.info(`XyoClientBluetoothNetwork.waitForJobToFinish()`)
    // eslint-disable-next-line no-async-promise-executor
    return new Promise<void>((resolve) => {
      this.onClose = () => {
        resolve(undefined)
      }
    })
  }

  public async findWithTimeout(timeoutInMills: number): Promise<IXyoNetworkPipe | void> {
    this.logger.info(`XyoClientBluetoothNetwork.findWithTimeout()`)
    this.tryingDevice = false

    // eslint-disable-next-line no-async-promise-executor
    return new Promise((resolve, reject) => {
      this.logger.info(`XyoClientBluetoothNetwork.findWithTimeout() async`)
      // default no async/await
      this.scanner.startScan().then(() => {
        this.logger.info(`XyoClientBluetoothNetwork.findWithTimeout().startScan()`)
        let hasResumed = false

        // default async/await
        const onTimeout = () => {
          this.logger.info(`XyoClientBluetoothNetwork.findWithTimeout().startScan().onTimeout`)
          if (!hasResumed) {
            if (this.tryingDevice) {
              this.logger.info(`XyoClientBluetoothNetwork.findWithTimeout().onTimeout: this.tryingDevice { this.waitForJobToFinish }`)
              this.waitForJobToFinish()
            }

            this.logger.info(`XyoClientBluetoothNetwork.findWithTimeout().onTimeout: this.shutDown()`)
            this.shutDown()
            resolve(undefined)
          }
        }

        XyoBase.timeout(onTimeout, timeoutInMills)

        // this async breaks things, but without it a timeout occurs
        this.onPipe = async (pipe: IXyoNetworkPipe) => {
          hasResumed = true
          try {
            this.logger.info(`XyoClientBluetoothNetwork.onPipe().shutDown()`)
            await this.shutDown()
            resolve(pipe)
          } catch (e) {
            this.logger.info(`XyoClientBluetoothNetwork.onPipe(): ${ e }`)
            reject(`XyoClientBluetoothNetwork.onPipe()`)
          }
        }

        this.scanInterval = setInterval(this.scanLambda, 1_000)

      }).catch(async (error) => {
        this.logger.info(`Error: ${ error }`)
        resolve(undefined)
      })
    })
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  public find(_catalogue: IXyoNetworkProcedureCatalogue): Promise<IXyoNetworkPipe> {
    this.tryingDevice = false

    // eslint-disable-next-line no-async-promise-executor
    return new Promise(async (resolve) => {
      await this.scanner.startScan()
      this.logger.info(`XyoClientBluetoothNetwork.find()`)

      this.onPipe = (pipe: IXyoNetworkPipe) => {
        this.shutDown() // default no async/await
        resolve(pipe)
      }

      this.scanInterval = setInterval(this.scanLambda, 1_000)
    })
  }

  public stopServer(): Promise<void> {
    this.logger.info(`XyoClientBluetoothNetwork.stopServer(): stopScan()`)
    return this.scanner.stopScan() // default no async/await
  }
}
