import { XyoBase } from '@xyo-network/base'
import { IXyoMutableCharacteristic } from '@xyo-network/ble-peripheral'
import { XyoLogger } from '@xyo-network/logger'
import { IXyoNetworkPeer, IXyoNetworkPipe } from '@xyo-network/network'
import { IXyoSerializableObject } from '@xyo-network/serialization'
import { XyoInputStream } from './data/xyo-input-stream'
import { chunkBytes } from './data/xyo-output-stream'

export class XyoCharacteristicHandle implements IXyoNetworkPipe {
    private logger: XyoLogger = new XyoLogger(false, false)
    private characteristic: IXyoMutableCharacteristic
    private packetCompleteCallback: ((packet: Buffer) => void) | undefined = undefined
    private inputStream: XyoInputStream = new XyoInputStream()
    private onClose: (id: string) => void

    peer: IXyoNetworkPeer
    initiationData: Buffer | undefined = undefined
    networkHeuristics: IXyoSerializableObject[]

    constructor (
        peer: IXyoNetworkPeer, 
        initiationData: Buffer,
        characteristic: IXyoMutableCharacteristic,
        onClose: (id: string) => void) {
        this.onClose = onClose
        this.networkHeuristics = []
        this.peer = peer
        this.initiationData = initiationData
        this.characteristic = characteristic
    }
    

    public onWrite(value: Buffer) {
        this.logger.info(`Handler received write: ${ value.toString("hex") }`)

        this.inputStream.addChunk(value)

        const newPacket = this.inputStream.getOldestPacket()
        const callback = this.packetCompleteCallback

        if (newPacket && callback) {
            callback(newPacket)
        }
    }

    private async delay(mills: number): Promise<void> {
        this.logger.info(`XyoCharacteristicHandle.delay()`)
        return new Promise((resolve) => {
            const onDone = () => {
                resolve()
            }
    
            XyoBase.timeout(onDone, mills)
        })
    }

    private async chunkSend(data: Buffer) {
        // const timeout = new Promise<IXyoNetworkPipe>((_, reject) => {
        //     XyoBase.timeout(async () => {
        //         reject(`chunkSend().timeout()`) // Promise<null>; reject()
        //     }, 10_000)
        // })

        // // eslint-disable-next-line no-async-promise-executor
        // const promise = new Promise<IXyoNetworkPipe>(async (resolve) => {
        //     this.logger.info(`Chunk send for server, entire: ${ data.toString("hex") }`)
        //     // todo add timeout

        //     const sizeBuffer = Buffer.alloc(4)
        //     sizeBuffer.writeUInt32BE(data.length + 4, 0)
        //     const sizeEncodedBuffer = Buffer.concat([ sizeBuffer, data ])

        //     // todo get MTU for chunking instead of fixed 20 bytes
        //     const chunksToSend = chunkBytes(sizeEncodedBuffer, 20) 

        //     for (const chunk of chunksToSend) {
        //         this.logger.info(`Sending chunk: ${ chunk.toString("hex") }`)
        //         this.characteristic.value = chunk
        //         await this.delay(200)
        //         await this.characteristic.notifyChanged()
        //     }
        //     resolve(this)
        // })
        // return Promise.race([ promise, timeout ])

        this.logger.info(`Chunk send for server, entire: ${ data.toString("hex") }`)
        // todo add timeout

        const sizeBuffer = Buffer.alloc(4)
        sizeBuffer.writeUInt32BE(data.length + 4, 0)
        const sizeEncodedBuffer = Buffer.concat([ sizeBuffer, data ])

        // todo get MTU for chunking instead of fixed 20 bytes
        const chunksToSend = chunkBytes(sizeEncodedBuffer, 20) 

        for await (const chunk of chunksToSend) {
            this.logger.info(`Sending chunk: ${ chunk.toString("hex") }`)
            this.characteristic.value = chunk
            await this.delay(200)
            await this.characteristic.notifyChanged()
        }
    }

    private async waitForWrite(): Promise<Buffer | undefined> {
        // todo add timeout
        this.logger.info(`Waiting for write`)
    
        // eslint-disable-next-line no-async-promise-executor
        return new Promise(async (resolve) => {
            this.logger.info(`XyoCharacteristicHandle().waitForWrite()`)
            let hasResumed = false

            const onTimeout = async () => {
                this.logger.info(`XyoCharacteristicHandle().onTimeout`)
                if (!hasResumed) {
                    hasResumed = true
                    this.packetCompleteCallback = undefined
                    resolve(undefined)
                }
            }

            XyoBase.timeout(onTimeout, 30_000)

            this.packetCompleteCallback = async (value: Buffer) => {
                if (!hasResumed) {
                    this.logger.info(`PacketCompleteCallback resolved`)
                    hasResumed = true
                    this.packetCompleteCallback = undefined
                    resolve(value)
                }
            }
        })
    }

    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onPeerDisconnect(_callback: (hasError: boolean) => void): () => void {
        return () => { this.logger.info(`onPeerDisconnect()`) }
    }

    async send(data: Buffer, awaitResponse?: boolean): Promise<Buffer | undefined> {
        this.logger.info(`Will chunk send`)
        await this.chunkSend(data)
        this.logger.info(`Done chunk send`)

        if (awaitResponse != false) {
            this.logger.info(`Will receive`)
            return this.waitForWrite()
        }

        return undefined
    }

    async close(): Promise<void> {
        this.logger.info(`XyoCharacteristicHandle.close()`)
        const callback = this.onClose

        if (callback) {
            // todo, find a wait to get await notifaction so we do not have this delay
            await this.delay(500)
            // todo get id of device
            callback("0")
        }
    }
}
