import { IXyoBluetoothDevice, IXyoCharacteristic } from "@xyo-network/ble-central"
import { IXyoNetworkPipe, IXyoNetworkPeer, CatalogueItem } from '@xyo-network/network'
import { XyoLogger } from '@xyo-network/logger'
import { IXyoSerializableObject } from '@xyo-network/serialization'
import { rssiSerializationProvider } from '@xyo-network/heuristics-common'
import { XyoBase } from '@xyo-network/base'
import { chunkBytes } from "../data/xyo-output-stream";

export class XyoPipeClient implements IXyoNetworkPipe {
  public networkHeuristics: IXyoSerializableObject[] = []
  public logger: XyoLogger = new XyoLogger(false, false)

  public peer: IXyoNetworkPeer
  public otherCatalogue: CatalogueItem[] | undefined
  public initiationData: Buffer | undefined
  private sessionCharacteristic!: IXyoCharacteristic | null
  private device: IXyoBluetoothDevice

  constructor(device: IXyoBluetoothDevice) {
    this.device = device

    this.peer = {
      getTemporaryPeerId(): Buffer {
        return Buffer.from(device.id)
      }
    }
  }

  public onPeerDisconnect(_callback: (hasError: boolean) => void): () => void {
    return () => {
      this.logger.info(`onPeerDisconnect()`)
      console.log("disconnect")
    }
  }

  public async tryCreatePipe(): Promise<IXyoNetworkPipe | null> {
    const timeout = new Promise<IXyoNetworkPipe | null>((_, reject) => {
      XyoBase.timeout(() => {
        this.device.disconnect()
        this.logger.info(`tryCreatePipe(): Timeout`)
        reject("Timeout")
      }, 10_000)
    })

    const promise = new Promise<IXyoNetworkPipe | null>(async (resolve, reject) => {
      try {
        if (this.device.state !== 'connected') {
          await this.device.connect()
          this.logger.info(`connect()`)
        }
  
        const services = await this.device.discoverServicesForUuids(["d684352edf36484ebc982d5398c5593e"])
  
        if (services.length === 1) {
          const characteristics = await services[0].discoverCharacteristics()
  
          const xyoPipeChar = characteristics.filter((characteristic) => {
            return characteristic.uuid === "727a36390eb44525b1bc7fa456490b2d"
          })
  
          if (xyoPipeChar.length === 1) {
            this.sessionCharacteristic = xyoPipeChar[0]
            await xyoPipeChar[0].subscribe()
            this.networkHeuristics = [rssiSerializationProvider.newInstance(this.device.rssi)]
            resolve(this)
            return
          }
  
          await this.device.disconnect()
          reject("No XYO pipe characteristic 1")
          return
        }

        await this.device.disconnect()
        reject("No XYO service")
      } catch (error) {
        // timeout if here

        await this.device.disconnect()
        reject("Timeout error caught")
      }
    })

    return await Promise.race([promise, timeout])
  }

  public async send (data: Buffer, awaitResponse?: boolean): Promise<Buffer | undefined> {
    if (this.sessionCharacteristic != null) {
      await this.chunkSend(data, this.sessionCharacteristic)

      if (awaitResponse !== false) {
        return this.read(this.sessionCharacteristic)
      }

      return undefined
    }

    throw Error("No XYO pipe characteristic 2")
  }

  public async close(): Promise<void> {
    await this.device.disconnect()
  }

  public read (characteristic: IXyoCharacteristic): Promise<Buffer> {
    const timeout = new Promise((_resolve, reject) => {
      XyoBase.timeout(() => {
        reject("Timeout")
      }, 12000)
    }) as Promise<Buffer>

    const action = new Promise((resolve, _reject) => {
      let buffer: Buffer
      let bytesReceived = 0

      const onData = (data: Buffer, _isNotification: boolean) => {
        if (bytesReceived === 0) {
          bytesReceived = data.readUInt32BE(0)
          buffer = data.subarray(4, data.length)

          if (buffer.length === bytesReceived - 4) {
            resolve(buffer)
          }

          return
        }

        buffer = Buffer.concat([buffer, data])

        if (buffer.length === bytesReceived - 4) {
          resolve(buffer)
        }
      }

      characteristic.on("notification", onData)
    }) as Promise < Buffer >

    return Promise.race([timeout, action])
  }

  public async chunkSend(data: Buffer, characteristic: IXyoCharacteristic): Promise < void > {
    const timeout = new Promise((_resolve, reject) => {
      XyoBase.timeout(() => {
        reject("Timeout")
      }, 10000)
    })

    const action = new Promise<void>(async (resolve, _reject) => {

      const chunksToSend = chunkBytes(this.addBleSize(data), 20)
      this.logger.info(`Sending entire: ${data.toString('hex')}`)

    // tslint:disable-next-line:prefer-for-of
      for (let i = 0; i < chunksToSend.length; i++) {
        await characteristic.write(chunksToSend[i])
      }
      resolve()
    })

    await Promise.race([timeout, action])
  }

  private addBleSize(data: Buffer): Buffer {
    const buffer = Buffer.alloc(4)
    buffer.writeUInt32BE(data.length + 4, 0)
    return Buffer.concat([buffer, data])
  }

}
