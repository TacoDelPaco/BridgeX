import { XyoBase } from '@xyo-network/base'
import { IXyoBluetoothDevice, IXyoCharacteristic } from "@xyo-network/ble-central"
import { rssiSerializationProvider } from '@xyo-network/heuristics-common'
import { XyoLogger } from '@xyo-network/logger'
import { CatalogueItem, IXyoNetworkPeer, IXyoNetworkPipe } from '@xyo-network/network'
import { IXyoSerializableObject } from '@xyo-network/serialization'
import { chunkBytes } from "../data/xyo-output-stream"

export class XyoPipeClient implements IXyoNetworkPipe {
  public networkHeuristics: IXyoSerializableObject[] = []
  public logger: XyoLogger = new XyoLogger(false, false)

  public peer: IXyoNetworkPeer
  public otherCatalogue: CatalogueItem[] | undefined
  public initiationData: Buffer | undefined
  private sessionCharacteristic!: IXyoCharacteristic | null
  private device: IXyoBluetoothDevice

  constructor (device: IXyoBluetoothDevice) {
    this.device = device

    this.peer = {
      getTemporaryPeerId(): Buffer {
        return Buffer.from(device.id)
      }
    }
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  public onPeerDisconnect(_callback: (hasError: boolean) => void): () => void {
    return () => { this.logger.info(`XyoPipeClient.onPeerDisconnect()`) }
  }

  public async tryCreatePipe(): Promise<IXyoNetworkPipe> {
    const timeout = new Promise<IXyoNetworkPipe>((_, reject) => {
      XyoBase.timeout(() => {
        reject(`XyoPipeClient.tryCreatePipe(): timeout()`) // Promise<null>; reject()
      }, 10_000)
    })

    // eslint-disable-next-line no-async-promise-executor
    const promise = new Promise<IXyoNetworkPipe>(async (resolve, reject) => {
      try {
        if (this.device.state !== 'connected') {
          await this.device.connect()
          this.logger.info(`XyoPipeClient.tryCreatePipe(): connect()`)
        }
  
        const services = await this.device.discoverServicesForUuids([ "d684352edf36484ebc982d5398c5593e" ])
  
        if (services.length === 1) {
          const characteristics = await services[ 0 ].discoverCharacteristics()
          const xyoPipeChar = characteristics.filter((characteristic: { uuid: string }) => {
            return characteristic.uuid === "727a36390eb44525b1bc7fa456490b2d"
          })
  
          if (xyoPipeChar.length === 1) {
            this.sessionCharacteristic = xyoPipeChar[ 0 ]
            await xyoPipeChar[ 0 ].subscribe()
            this.networkHeuristics = [ rssiSerializationProvider.newInstance(this.device.rssi) ]
            resolve(this)
            return
          }
  
          await this.device.disconnect()
          reject("No XYO pipe characteristic 1")
          return
        }

        await this.device.disconnect()
        reject("No XYO service")
        return
      } catch (error) {
        // timeout if here
        this.logger.error(`XyoPipeClient.tryCreatePipe().connect(): ${ error }`)
        reject("Timeout error caught")
        await this.device.disconnect()
        return
      }
    })
    return await Promise.race([ promise, timeout ])
  }

  public async send(data: Buffer, awaitResponse?: boolean): Promise<Buffer | undefined> {
    if (this.sessionCharacteristic != null) {
      await this.chunkSend(data, this.sessionCharacteristic)

      if (awaitResponse !== false) {
        return this.read(this.sessionCharacteristic)
      }
    }
    throw Error("No XYO pipe characteristic 2")
  }

  public async close(): Promise<void> {
    this.logger.info(`XyoPipeClient.close(): disconnect()`)
    await this.device.disconnect()
  }

  public read(characteristic: IXyoCharacteristic): Promise<Buffer> {
    const timeout = new Promise((_, reject) => {
      XyoBase.timeout(() => {
        reject(`XyoPipeClient.read(): timeout() ${ characteristic.uuid }`)
      }, 12_000)
    }) as Promise<Buffer>

    const action = new Promise((resolve) => {
      let buffer: Buffer
      let bytesReceived = 0

      const onData = async (data: Buffer, isNotification: boolean) => {
        if (isNotification) return

        if (bytesReceived === 0) {
          bytesReceived = data.readUInt32BE(0)
          buffer = data.subarray(4, data.length)

          if (buffer.length === bytesReceived - 4) resolve(buffer)

          return
        }

        buffer = Buffer.concat([ buffer, data ])
        if (buffer.length === bytesReceived - 4) resolve(buffer)
      }

      characteristic.on("notification", onData)
    }) as Promise<Buffer>

    return Promise.race([ timeout, action ])
  }

  public async chunkSend(data: Buffer, characteristic: IXyoCharacteristic): Promise<void> {
    const timeout = new Promise<void>((_resolve, reject) => {
      XyoBase.timeout(() => {
        reject("XyoPipeClient.chunkSend(): timeout()")
      }, 10_000)
    })

    const action = new Promise<void>((resolve) => {

      const chunksToSend = chunkBytes(this.addBleSize(data), 20)
      this.logger.info(`Sending entire: ${ data.toString('hex') }`)

      chunksToSend.forEach(async (_, index) => {
        await characteristic.write(chunksToSend[ index ])
      })

      resolve()
    })
    return Promise.race([ timeout, action ])
  }

  private addBleSize(data: Buffer): Buffer {
    const buffer = Buffer.alloc(4)
    buffer.writeUInt32BE(data.length + 4, 0)
    return Buffer.concat([ buffer, data ])
  }
}

