"use strict";
/*
* @Author: XY | The Findables Company <ryanxyo>
* @Date:   Thursday, 7th February 2019 11:32:52 am
* @Email:  developer@xyfindables.com
* @Filename: xyo-bound-witness-success-listener.ts
* @Last modified by: ryanxyo
* @Last modified time: Thursday, 7th February 2019 11:33:33 am
* @License: All Rights Reserved
* @Copyright: Copyright XY | The Findables Company
*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.XyoBoundWitnessSuccessListener = void 0;
const base_1 = require("@xyo-network/base");
const utils_1 = require("@xyo-network/utils");
const xyo_nested_bound_witness_extractor_1 = require("./xyo-nested-bound-witness-extractor");
class XyoBoundWitnessSuccessListener extends base_1.XyoBase {
    // BRIDGE
    constructor(hashingProvider, boundWitnessValidator, originChainRepository, originBlockRepository, contentAddressableService) {
        super();
        this.hashingProvider = hashingProvider;
        this.boundWitnessValidator = boundWitnessValidator;
        this.originChainRepository = originChainRepository;
        this.originBlockRepository = originBlockRepository;
        this.contentAddressableService = contentAddressableService;
    }
    onBoundWitnessSuccess(boundWitness, mutex, _choice) {
        return __awaiter(this, void 0, void 0, function* () {
            const hashValue = yield this.hashingProvider.createHash(boundWitness.getSigningData());
            // tslint:disable-next-line:prefer-array-literal
            const content = [];
            try {
                yield this.boundWitnessValidator.validateBoundWitness(hashValue, boundWitness);
            }
            catch (err) {
                this.logError(`Origin block failed validation. Will not add.`, err);
                throw err;
            }
            yield this.originBlockRepository.addOriginBlock(hashValue, boundWitness);
            yield this.originChainRepository.updateOriginChainState(hashValue, boundWitness, mutex);
            content.push(new utils_1.XyoPair(hashValue, boundWitness.getSigningData()));
            this.logInfo(`${hashValue.serializeHex()} added to Origin-Chain and Origin-Block-Repository`);
            const nestedBoundWitnesses = new xyo_nested_bound_witness_extractor_1.XyoNestedBoundWitnessExtractor().extractNestedBoundWitnesses(boundWitness);
            yield nestedBoundWitnesses.reduce((promiseChain, nestedBoundWitness) => __awaiter(this, void 0, void 0, function* () {
                yield promiseChain;
                const nestedBw = nestedBoundWitness.getSigningData();
                const nestedHashValue = yield this.hashingProvider.createHash(nestedBw);
                const nestedHash = nestedHashValue.serialize();
                this.logInfo(`Extracted nested block with hash ${nestedHash.toString('hex')}`);
                const containsBlock = yield this.originBlockRepository.containsOriginBlock(nestedHash);
                if (!containsBlock) {
                    try {
                        yield this.boundWitnessValidator.validateBoundWitness(nestedHashValue, nestedBoundWitness);
                    }
                    catch (err) {
                        this.logError(`Origin block failed validation. Will not add.`, err);
                        throw err;
                    }
                    const bwToPersist = nestedBoundWitness.stripMetaData();
                    content.push(new utils_1.XyoPair(nestedHashValue, bwToPersist.serialize()));
                    yield this.originBlockRepository.addOriginBlock(nestedHashValue, bwToPersist, hashValue);
                }
            }), Promise.resolve());
            // Fire and forget
            Promise.all(content.map(({ k, v }) => __awaiter(this, void 0, void 0, function* () {
                try {
                    const b58Key = yield this.contentAddressableService.add(v);
                    this.logInfo(`Successfully upload bound witness with hash ${k.serializeHex()}, address is: ${b58Key}`);
                }
                catch (err) {
                    // log and swallow error
                    this.logError(`There was an error uploading bound witness with hash ${k.serializeHex()}`, err);
                }
            })));
            return;
        });
    }
}
exports.XyoBoundWitnessSuccessListener = XyoBoundWitnessSuccessListener;
//# sourceMappingURL=xyo-bound-witness-success-listener.js.map