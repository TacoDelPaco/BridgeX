"use strict";
/*
 * @Author: XY | The Findables Company <ryanxyo>
 * @Date:   Wednesday, 21st November 2018 1:25:45 pm
 * @Email:  developer@xyfindables.com
 * @Filename: xyo-bound-wit
 * @Last modified by: ryanxyo
 * @Last modified time: Monday, 10th December 2018 2:26:27 pm
 * @License: All Rights Reserved
 * @Copyright: Copyright XY | The Findables Company
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = require("@xyo-network/base");
const origin_chain_1 = require("@xyo-network/origin-chain");
class XyoBoundWitnessPayloadProvider extends base_1.XyoBase {
    constructor() {
        super(...arguments);
        /** A mapping of name to unsigned-heuristic-providers */
        this.unsignedHeuristicsProviders = {};
        /** A mapping of name to signed-heuristic-providers */
        this.signedHeuristicsProviders = {};
        this.boundWitnessOptions = {};
    }
    /**
     * A helper function for composing the payload values that will go
     * inside a bound witness
     */
    getPayload(originState, choice) {
        return __awaiter(this, void 0, void 0, function* () {
            const signedHeuristics = yield this.getHeuristics(true);
            const unsignedHeuristics = yield this.getHeuristics(false);
            const unsignedPayload = [].concat(unsignedHeuristics);
            const signedPayload = [].concat(signedHeuristics);
            const previousHash = yield originState.getPreviousHash();
            const index = yield originState.getIndex();
            const nextPublicKey = yield originState.getNextPublicKey();
            const boundWitnessOptionsSigned = yield this.getOptionsSigned(choice);
            const boundWitnessOptionsUnsigned = yield this.getOptionsUnsigned(choice);
            if (previousHash) {
                signedPayload.push(new origin_chain_1.XyoPreviousHash(previousHash));
            }
            if (nextPublicKey) {
                signedPayload.push(new origin_chain_1.XyoNextPublicKey(nextPublicKey));
            }
            signedPayload.push(new origin_chain_1.XyoIndex(index));
            boundWitnessOptionsSigned.forEach((item) => {
                signedPayload.push(item);
            });
            boundWitnessOptionsUnsigned.forEach((item) => {
                unsignedPayload.push(item);
            });
            return {
                heuristics: signedPayload,
                metadata: unsignedPayload,
            };
        });
    }
    /**
     * Register a heuristics provider with the xyo-node. The values of the heuristic
     * provider will be placed in the bound-witness
     *
     * @param name The name of the heuristics provider
     * @param signed true if it should go into the signed payload, false if it should go into the unsigned payload
     * @param providerFn A callback function that asynchronously returns a value
     */
    addHeuristicsProvider(name, signed, providerFn) {
        if (signed) {
            this.signedHeuristicsProviders[name] = providerFn;
        }
        else {
            this.unsignedHeuristicsProviders[name] = providerFn;
        }
    }
    /**
     * Removes a heuristics provider
     * @param name The name of the heuristics provider
     * @param signed true if it should remove from the signed payload, false if it should remove from the unsigned payload
     */
    removeHeuristicsProvider(name, signed) {
        if (signed) {
            delete this.signedHeuristicsProviders[name];
        }
        else {
            delete this.unsignedHeuristicsProviders[name];
        }
    }
    addBoundWitnessOption(option, boundWitnessOption) {
        this.boundWitnessOptions[option] = boundWitnessOption;
    }
    removeBoundWitnessOption(option) {
        delete this.boundWitnessOptions[option];
    }
    getOptionsSigned(option) {
        return __awaiter(this, void 0, void 0, function* () {
            const optionHandler = this.boundWitnessOptions[option];
            if (optionHandler) {
                const signedPayload = yield optionHandler.signed();
                if (signedPayload) {
                    return [signedPayload];
                }
            }
            return [];
        });
    }
    getOptionsUnsigned(option) {
        return __awaiter(this, void 0, void 0, function* () {
            const optionHandler = this.boundWitnessOptions[option];
            if (optionHandler) {
                const unsignedPayload = yield optionHandler.unsigned();
                if (unsignedPayload) {
                    return [unsignedPayload];
                }
            }
            return [];
        });
    }
    /**
     * Iterates through the heuristics providers and resolves
     * their values
     */
    getHeuristics(signed) {
        return __awaiter(this, void 0, void 0, function* () {
            const heuristicsProvider = signed ? this.signedHeuristicsProviders : this.unsignedHeuristicsProviders;
            if (Object.keys(heuristicsProvider).length === 0) {
                return [];
            }
            return Promise.all(Object.keys(heuristicsProvider).map((heuristicName) => {
                const providerFn = heuristicsProvider[heuristicName];
                return providerFn();
            }));
        });
    }
}
exports.XyoBoundWitnessPayloadProvider = XyoBoundWitnessPayloadProvider;
//# sourceMappingURL=xyo-bound-witness-payload-provider.js.map