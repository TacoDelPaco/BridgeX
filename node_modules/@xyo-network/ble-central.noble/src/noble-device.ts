import { IXyoAdvertisement, IXyoBluetoothDevice, IXyoService } from "@xyo-network/ble-central"
import { XyoLogger } from '@xyo-network/logger'
import { NobleAdvertisement } from './noble-advertisement'
import { NobleService } from './noble-service'
// import noble from '@s524797336/noble-mac'
import noble from '@abandonware/noble'

export class NobleDevice implements IXyoBluetoothDevice {
  public logger: XyoLogger = new XyoLogger(false, false)
  public device: noble.Peripheral
  public lastSeen: number = Date.now()

  public get id(): string {
    return this.device.id
  }

  public get uuid(): string {
    return this.device.uuid
  }

  public get connectable(): boolean {
    return this.device.connectable
  }

  public get advertisement(): IXyoAdvertisement {
    return new NobleAdvertisement(this.device.advertisement)
  }

  public get rssi(): number {
    return this.device.rssi
  }

  public get services(): IXyoService[] {
    const returnArray: IXyoService[] = []

    this.device.services.forEach((service) => {
      returnArray.push(new NobleService(service))
    })

    return returnArray
  }

  public get state(): 'error' | 'connecting' | 'connected' | 'disconnecting' | 'disconnected' {
    return this.device.state
  }

  constructor (device: noble.Peripheral) {
    this.device = device
  }

  public connect(): Promise<void> {
    // eslint-disable-next-line no-async-promise-executor
    return new Promise((resolve, reject) => {
      this.logger.info(`Trying to connect to device with id: ${ this.device.id }`)

      const timeout = setTimeout(() => {
        // this.device.cancelConnect()
        reject(`NobleDevice.connect(): setTimeout()`)
      }, 10_000)

      try {
        this.device.connectAsync()
        clearTimeout(timeout)
        this.logger.info(`Connected to device with id: ${ this.device.id }`)
        resolve()
      } catch { 
        clearTimeout(timeout)
        reject(`connect(): Error`)
      }
    })
  }

  public disconnect(): Promise<void> {
    // eslint-disable-next-line no-async-promise-executor
    return new Promise((resolve, reject) => {
      this.logger.info(`Trying to disconnect to device with id: ${ this.device.id }`)

      try {
        this.device.disconnectAsync()
        this.logger.info(`Disconnected from device with id: ${ this.device.id }`)
        resolve()
      } catch {
        reject(`disconnect(): Error`)
      }
    })
  }

  public updateRssi(): Promise<number> {
    // eslint-disable-next-line no-async-promise-executor
    return new Promise((resolve, reject) => {
      this.logger.info(`Trying to update device RSSI with id: ${ this.device.id }`)

      try {
        this.device.updateRssiAsync()
        this.logger.info(`Updated RSSI for device with id: ${ this.device.id }`)
        resolve(this.rssi)
      } catch {
        this.logger.error(`Error updating RSSI for device with id: ${ this.device.id }`)
        reject(`updateRssi(): Error`)
      }
    })
  }

  public discoverServicesForUuids(serviceUUIDs: string[]): Promise<IXyoService[]> {
    // eslint-disable-next-line no-async-promise-executor
    return new Promise(async (resolve, reject) => {
      this.logger.info(`Trying to discover services for device with id: ${ this.device.id }`)

      try {
        this.logger.info(`Successfully discovered services for device with id: ${ this.device.id }`)
        const services = await this.device.discoverServicesAsync(serviceUUIDs)
        const returnArray: IXyoService[] | PromiseLike<IXyoService[]> | NobleService[] = []

        services.forEach((service: noble.Service) => {
          returnArray.push(new NobleService(service))
        })

        resolve(returnArray)
      } catch {
        reject(`discoverServicesAsync(): Error`)
      }
      

      /*
      this.device.discoverServices(serviceUUIDs, (error, services) => {
        if (error == null) {
          this.logger.info(`Successfully discovered services for device with id: ${ this.device.id }`)
          const returnArray: IXyoService[] | PromiseLike<IXyoService[]> | NobleService[] = []

          services.forEach((service) => {
            returnArray.push(new NobleService(service))
          })

          resolve(returnArray)
        } else {
          this.logger.error(`Error discovering services for device with id: ${ this.device.id }`)
          reject(error)
        }
      })
      */
      
    })
  }

  public discoverServices(): Promise<IXyoService[]> {
    this.logger.info(`Attempting to discover services...`)
    return this.discoverServicesForUuids([])
  }
}
