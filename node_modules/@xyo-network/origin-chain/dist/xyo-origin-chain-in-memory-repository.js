"use strict";
/*
 * @Author: XY | The Findables Company <ryanxyo>
 * @Date:   Wednesday, 21st November 2018 1:38:47 pm
 * @Email:  developer@xyfindables.com
 * @Filename: xyo-origin-chain-in-memory-repository.ts
 * @Last modified by: ryanxyo
 * @Last modified time: Wednesday, 6th March 2019 4:42:51 pm
 * @License: All Rights Reserved
 * @Copyright: Copyright XY | The Findables Company
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = require("@xyo-network/base");
const bound_witness_1 = require("@xyo-network/bound-witness");
const errors_1 = require("@xyo-network/errors");
const xyo_index_1 = require("./xyo-index");
const xyo_next_public_key_1 = require("./xyo-next-public-key");
/**
 * Encapsulates the values that go into an origin-chain managements
 */
class XyoOriginChainStateInMemoryRepository extends base_1.XyoBase {
    constructor(index, originChainHashes, allPublicKeys, originBlockResolver, currentSigners, nextPublicKey, waitingSigners, serializationService, genesisSigner) {
        super();
        this.originChainHashes = originChainHashes;
        this.originBlockResolver = originBlockResolver;
        this.currentSigners = currentSigners;
        this.nextPublicKey = nextPublicKey;
        this.waitingSigners = waitingSigners;
        this.serializationService = serializationService;
        this.genesisSigner = genesisSigner;
        this.publicKeyIndex = {};
        this.hashIndex = {};
        this.idx = index;
        // Initialize originChainHashIndex
        this.originChainHashes.forEach(h => this.hashIndex[h.serializeHex()] = true);
        // Initialize publicKeyIndex
        allPublicKeys.forEach(pk => this.publicKeyIndex[pk.serializeHex()] = true);
        currentSigners.forEach(signer => this.publicKeyIndex[signer.publicKey.serializeHex()] = true);
    }
    getOriginChainHashes() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.originChainHashes;
        });
    }
    getAllPublicKeysForOriginChain() {
        return __awaiter(this, void 0, void 0, function* () {
            return Object.keys(this.publicKeyIndex).map(pk => this.serializationService.deserialize(pk).hydrate());
        });
    }
    acquireMutex() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.mutex)
                return undefined;
            this.mutex = {
                isActive: true,
                date: new Date()
            };
            return this.mutex;
        });
    }
    releaseMutex(mutex) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.mutex)
                return;
            if (this.mutex !== mutex)
                throw new errors_1.XyoError(`Can not release mutex, does not exist`);
            this.mutex.isActive = false;
            this.mutex = undefined;
        });
    }
    canAcquireMutex() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.mutex !== undefined;
        });
    }
    /**
     * The index, or number of the blocks in the origin chain
     */
    get index() {
        return this.idx;
    }
    /**
     * Gets the previous hash value for the origin chain
     */
    get previousHash() {
        return this.originChainHashes.length && this.originChainHashes[this.originChainHashes.length - 1] || undefined;
    }
    getIndex() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.index;
        });
    }
    createGenesisBlock() {
        return __awaiter(this, void 0, void 0, function* () {
            const currentIndex = yield this.getIndex();
            if (currentIndex !== 0) {
                throw new errors_1.XyoError(`Could not create Genesis block as one already exists`);
            }
            this.logInfo(`Creating genesis block`);
            const signers = yield this.getSigners();
            const fetter = new bound_witness_1.XyoFetter(new bound_witness_1.XyoKeySet(signers.map(signer => signer.publicKey)), [new xyo_index_1.XyoIndex(0)]);
            const signingData = fetter.serialize();
            const signatures = yield Promise.all(signers.map(signer => signer.signData(signingData)));
            const genesisBlock = new bound_witness_1.XyoBoundWitness([
                fetter,
                new bound_witness_1.XyoWitness(new bound_witness_1.XyoSignatureSet(signatures), [])
            ]);
            return genesisBlock;
        });
    }
    getPreviousHash() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.previousHash;
        });
    }
    getNextPublicKey() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.nextPublicKey;
        });
    }
    getWaitingSigners() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.waitingSigners;
        });
    }
    updateOriginChainState(hash, block) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.newOriginBlock(hash, block);
            return;
        });
    }
    /**
     * A list of signers that will be used in signing bound witnesses
     */
    getSigners() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.currentSigners;
        });
    }
    /**
     * Adds a signer to be used in the next bound-witness interaction.
     */
    addSigner(signer) {
        return __awaiter(this, void 0, void 0, function* () {
            this.nextPublicKey = signer.publicKey;
            this.waitingSigners.push(signer);
        });
    }
    /**
     * Set the current signers
     * @param signers A collection of signers to set for the current block
     */
    setCurrentSigners(signers) {
        return __awaiter(this, void 0, void 0, function* () {
            // this.currentSigners is immutable, so we empty then fill up the array
            while (this.currentSigners.length) {
                this.currentSigners.pop();
            }
            signers.forEach((s) => {
                this.currentSigners.push(s);
                this.publicKeyIndex[s.publicKey.serializeHex()] = true;
            });
        });
    }
    /**
     * Removes the oldest signer for the list of signers such that
     * the signer removed will not be used in signing bound witnesses
     * in the future
     */
    removeOldestSigner() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.currentSigners.length > 0) {
                this.currentSigners.splice(0, 1);
            }
        });
    }
    getGenesisSigner() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.genesisSigner;
        });
    }
    getInteractionWithPublicKey(publicKey) {
        return __awaiter(this, void 0, void 0, function* () {
            const interactionData = yield this.getOrInitializeInteractionsData();
            const interactions = interactionData.interactions[publicKey.serializeHex()];
            if (!interactions) {
                return [];
            }
            return interactions;
        });
    }
    isBlockInOriginChain(block, hash) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.hashIndex[hash.serializeHex()]) {
                return {
                    result: false,
                    indexOfPartyInBlock: undefined
                };
            }
            const indexOfParty = block.parties.findIndex((p) => {
                return p.keySet.keys.some(k => this.publicKeyIndex[k.serializeHex()]);
            });
            return {
                result: indexOfParty !== -1,
                indexOfPartyInBlock: indexOfParty !== -1 ? indexOfParty : undefined
            };
        });
    }
    publicKeyBelongsToOriginChain(publicKey) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.publicKeyIndex[publicKey.serializeHex()];
        });
    }
    /**
     * Sets the state so that the chain is ready for a new origin block
     */
    newOriginBlock(hash, block) {
        return __awaiter(this, void 0, void 0, function* () {
            this.nextPublicKey = undefined;
            this.originChainHashes.push(hash);
            this.hashIndex[hash.serializeHex()] = true;
            if (this.idx === 0) {
                this.logInfo(`Updating genesis signer`);
                this.genesisSigner = this.currentSigners.length > 0 ? this.currentSigners[0] : this.genesisSigner;
            }
            this.idx += 1;
            this.addWaitingSigner();
            const interactionsData = yield this.getOrInitializeInteractionsData();
            yield this.addBlockToInteractionData(block, hash, interactionsData);
        });
    }
    /**
     * Adds the next waiting signer to the list of signers to be used in signing bound witnesses
     */
    addWaitingSigner() {
        if (this.waitingSigners.length > 0) {
            this.currentSigners.push(this.waitingSigners[0]);
            this.publicKeyIndex[this.waitingSigners[0].publicKey.serializeHex()] = true;
            this.waitingSigners.splice(0, 1);
        }
    }
    getOrInitializeInteractionsData() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.interactionsByPublicKeyData) {
                return this.interactionsByPublicKeyData;
            }
            if (this.originChainHashes.length === 0) {
                this.interactionsByPublicKeyData = {
                    stop: false,
                    interactions: {},
                    previousParty: undefined
                };
                return this.interactionsByPublicKeyData;
            }
            const genesisBlock = yield this.originBlockResolver.getOriginBlockByHash(this.originChainHashes[0].serialize());
            // To disambiguate identity, a genesis block should have 1 publicKeySet
            if (!genesisBlock || genesisBlock.publicKeys.length !== 1) {
                this.interactionsByPublicKeyData = {
                    stop: false,
                    interactions: {},
                    previousParty: undefined
                };
                return this.interactionsByPublicKeyData;
            }
            const party = genesisBlock.parties[0];
            this.interactionsByPublicKeyData = {
                stop: false,
                interactions: {},
                previousParty: party
            };
            const result = yield this.addBlocksToInteractionData(this.originChainHashes.slice(1), this.interactionsByPublicKeyData);
            return result;
        });
    }
    addBlocksToInteractionData(blocks, data) {
        return blocks.reduce((memo, hash) => __awaiter(this, void 0, void 0, function* () {
            const m = yield memo;
            if (m.stop) {
                return m;
            }
            const block = yield this.originBlockResolver.getOriginBlockByHash(hash.serialize());
            if (!block) {
                m.stop = true;
                return m;
            }
            this.addBlockToInteractionData(block, hash, m);
            return m;
        }), Promise.resolve(data));
    }
    addBlockToInteractionData(block, hash, data) {
        const partyOfNextBlock = data.previousParty ? this.getPartyOfChildBlock(data.previousParty, block) : undefined;
        if (partyOfNextBlock === undefined) {
            data.stop = true;
            return;
        }
        block.parties.forEach((blockParty, index) => {
            if (index === partyOfNextBlock.partyIndex) {
                data.previousParty = partyOfNextBlock;
                return;
            }
            blockParty.keySet.keys.forEach((pk) => {
                const hexKey = pk.serializeHex();
                data.interactions[hexKey] = data.interactions[hexKey] || [];
                data.interactions[hexKey].push(hash);
            });
        });
    }
    getPartyOfChildBlock(assertedParty, block) {
        const nextPublicKey = assertedParty.getHeuristic(xyo_next_public_key_1.XyoNextPublicKey.schemaObjectId);
        if (nextPublicKey !== undefined) {
            const indexOfKeySet = block.publicKeys.findIndex((keyset) => {
                return keyset.keys.findIndex(k => k.isEqual(nextPublicKey.publicKey)) !== -1;
            });
            return indexOfKeySet !== -1 ? block.parties[indexOfKeySet] : undefined;
        }
        const index = block.publicKeys.findIndex((keySet) => {
            return assertedParty.keySet.keys.findIndex((key) => {
                return keySet.keys.findIndex(k => k.isEqual(key)) !== -1;
            }) !== -1;
        });
        return index !== -1 ? block.parties[index] : undefined;
    }
}
exports.XyoOriginChainStateInMemoryRepository = XyoOriginChainStateInMemoryRepository;
//# sourceMappingURL=xyo-origin-chain-in-memory-repository.js.map