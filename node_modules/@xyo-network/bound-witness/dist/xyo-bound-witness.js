"use strict";
/*
 * @Author: XY | The Findables Company <ryanxyo>
 * @Date:   Monday, 26th November 2018 2:52:10 pm
 * @Email:  developer@xyfindables.com
 * @Filename: xyo-base-bound-witness.ts
 * @Last modified by: ryanxyo
 * @Last modified time: Friday, 8th March 2019 12:07:16 pm
 * @License: All Rights Reserved
 * @Copyright: Copyright XY | The Findables Company
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.XyoBoundWitness = void 0;
const errors_1 = require("@xyo-network/errors");
const serialization_1 = require("@xyo-network/serialization");
const serialization_schema_1 = require("@xyo-network/serialization-schema");
const xyo_bound_witness_party_1 = require("./xyo-bound-witness-party");
const xyo_fetter_1 = require("./xyo-fetter");
const xyo_witness_1 = require("./xyo-witness");
class XyoBoundWitness extends serialization_1.XyoBaseSerializable {
    get publicKeys() {
        return this.fetterWitnessPairs.map(fetterWitnessPair => fetterWitnessPair.fetter.keySet);
    }
    get signatures() {
        return this.fetterWitnessPairs.map(fetterWitnessPair => fetterWitnessPair.witness.signatureSet);
    }
    get heuristics() {
        return this.fetterWitnessPairs.map(fetterWitnessPair => fetterWitnessPair.fetter.heuristics);
    }
    get metadata() {
        return this.fetterWitnessPairs.map(fetterWitnessPair => fetterWitnessPair.witness.metadata);
    }
    get numberOfParties() {
        return this.fetterWitnesses.reduce((memo, fw) => {
            return memo + ((fw.schemaObjectId === serialization_schema_1.schema.fetter.id) ? 1 : 0);
        }, 0);
    }
    get parties() {
        return this.fetterWitnessPairs.map((pair, index) => new xyo_bound_witness_party_1.XyoBoundWitnessParty(pair.fetter, pair.witness, index));
    }
    get fetterWitnessPairs() {
        return getFetterWitnessPair(this.fetterWitnesses);
    }
    constructor(fetterWitnesses, respectSign) {
        super(serialization_schema_1.schema);
        this.fetterWitnesses = fetterWitnesses;
        this.respectSign = respectSign;
        this.schemaObjectId = serialization_schema_1.schema.boundWitness.id;
    }
    stripMetaData() {
        return new XyoBoundWitness(this.fetterWitnesses.map((fw) => {
            if (fw.schemaObjectId === serialization_schema_1.schema.fetter.id)
                return fw;
            return new xyo_witness_1.XyoWitness(fw.signatureSet, []);
        }));
    }
    getHeuristicFromParty(partyIndex, schemaObjectId) {
        if (this.parties.length <= partyIndex) {
            throw new errors_1.XyoError(`Insufficient number of parties to complete request`);
        }
        return this.parties[partyIndex].getHeuristic(schemaObjectId);
    }
    getMetaDataItemFromParty(partyIndex, schemaObjectId) {
        if (this.parties.length <= partyIndex) {
            throw new errors_1.XyoError(`Insufficient number of parties to complete request`);
        }
        return this.parties[partyIndex].getMetaDataItem(schemaObjectId);
    }
    getSigningData() {
        return getSigningDataFromFetterWitnesses(this.fetterWitnesses);
    }
    getData() {
        return this.fetterWitnesses;
    }
    getReadableValue() {
        return {
            parties: this.publicKeys.map((publicKeySet, partyIndex) => {
                return {
                    signing: publicKeySet.keys.map((key, keyIndex) => {
                        return {
                            publicKey: {
                                type: key.getReadableName(),
                                rawKey: key.getReadableValue()
                            },
                            signature: {
                                type: this.signatures[partyIndex].signatures[keyIndex].getReadableName(),
                                rawSignature: this.signatures[partyIndex].signatures[keyIndex].getReadableValue(),
                            }
                        };
                    }),
                    heuristics: this.heuristics[partyIndex].reduce((memo, heuristic) => {
                        memo[heuristic.getReadableName()] = heuristic.getReadableValue();
                        return memo;
                    }, {}),
                    metadata: this.metadata[partyIndex].reduce((memo, metadata) => {
                        memo[metadata.getReadableName()] = metadata.getReadableValue();
                        return memo;
                    }, {}),
                };
            })
        };
    }
}
exports.XyoBoundWitness = XyoBoundWitness;
const getSigningDataFromFetterWitnesses = (fetterWitnessPairs) => {
    const buffers = [];
    fetterWitnessPairs.forEach((hello) => {
        if (hello.schemaObjectId === xyo_fetter_1.XyoFetter.deserializer.schemaObjectId) {
            buffers.push(hello.serialize());
        }
    });
    return Buffer.concat(buffers);
};
const getFetterWitnessPair = (fetterOrWitnesses) => {
    const result = fetterOrWitnesses.reduce((memo, fetterOrWitness, index) => {
        if (index < fetterOrWitnesses.length / 2) {
            memo.fetters.push(fetterOrWitness);
        }
        else {
            memo.witnesses.push(fetterOrWitness);
        }
        return memo;
    }, {
        fetters: [],
        witnesses: []
    });
    result.witnesses.reverse();
    return result.fetters.map((fetter, index) => new FetterWitnessPair(fetter, result.witnesses[index]));
};
class XyoBoundWitnessDeserializer {
    constructor() {
        this.schemaObjectId = serialization_schema_1.schema.boundWitness.id;
    }
    deserialize(data, serializationService) {
        const parseResult = serializationService.parse(data);
        const query = new serialization_1.ParseQuery(parseResult);
        return new XyoBoundWitness(query.mapChildren(item => serializationService
            .deserialize(item.readData(true))
            .hydrate()), data);
    }
}
XyoBoundWitness.deserializer = new XyoBoundWitnessDeserializer();
class FetterWitnessPair {
    constructor(fetter, witness) {
        this.fetter = fetter;
        this.witness = witness;
    }
}
//# sourceMappingURL=xyo-bound-witness.js.map