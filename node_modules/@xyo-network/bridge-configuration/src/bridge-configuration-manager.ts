import npmPackage from '../package.json'
import { IArchivist, IBridgeConfigurationManager } from './@types'

// tslint:disable-next-line
let mockPassword = ''
// tslint:disable-next-line
let mockPublicKey = '000c4114ab1adccbf3205ef2b524fe502fcdd2ee91ce3ea72898c6452cca510039e4ebfa3c7f133bfb415e1835337ecaed48195d576d5720c8cd729543a93e9e9b56ad'
// tslint:disable-next-line
let mockPaymentKey = '0x4aef1Fd68C9D0b17d85E0f4e90604F6c92883F18'
let mockArchivists: IArchivist[] = []

export class BridgeConfigurationManager implements IBridgeConfigurationManager {
  public async getPublicKey(): Promise<string> {
    return mockPublicKey
  }

  public async getPaymentKey(): Promise<string> {
    // tslint:disable-next-line
    return mockPaymentKey
  }

  public async setPaymentKey(paymentKey: string): Promise<string> {
    mockPaymentKey = paymentKey
    return paymentKey
  }

  public async setDefaultArchivist(id: string): Promise<IArchivist> {
    return {
      id
    }
  }

  public async getDefaultArchivist(): Promise<IArchivist> {
    return {}
  }

  public async attachArchivist(dns: string, port: number): Promise<IArchivist> {
    const id = `http://${dns}:${port}`
    const archivist = {
      id,
      dns,
      port
    }
    mockArchivists.push(archivist)
    return archivist
  }

  public async detachArchivist(id: string): Promise<IArchivist> {
    mockArchivists = mockArchivists.filter(archivist => archivist.id !== id)
    return {
      id
    }
  }

  public async getAttachedArchivists(): Promise<IArchivist[]> {
    return mockArchivists
  }

  public async verifyPin(pin: string): Promise<boolean> {
    return pin === mockPassword
  }

  public async updatePin(oldPin: string, newPin: string): Promise<boolean> {
    if (mockPassword && oldPin !== mockPassword) throw new Error('Invalid')
    mockPassword = newPin
    return true
  }

  public async isConfigured(): Promise<boolean> {
    return !!mockPassword
  }

  public async forceUpdate() {
    execAsync('echo "Unattended upgrade"')
      .then(d => console.log('UNATTENDED', d))
      .catch(e => console.log('ERROR', e))
    return true       
  }

  public async factoryReset() {
    await execAsync('echo "sudo rm -rf /var/opt/bridge-store && sudo reboot"')
  }

  public async checkForUpdates() {
    await execAsync('echo "apt upgrade"')
    return true
  }

  public async lastResort() {
    execAsync("sudo sh -c 'curl -L https://s3.amazonaws.com/xyo-bridge-images/last-resort.sh | sh'")
      .then(d => console.log('Last resort', d))
      .catch(e => console.log('ERROR', e))
    return true       
  }

  public async tailLog(pathname: string, n = 5) {
    try {
      const stdOut = await execAsync(`tail -${n} ${pathname}`)
      return stdOut
    } catch (e: any) {
      return e.message
    }
  }

  public async getAptPackageVersion() {
    const updateOut = await execAsync('echo "xyo-bridge\n\tInstalled: 0.0.50\n\tCandidate: 0.0.51\n\tVersion table:"')
    const [latest] = updateOut.match(/Candidate: (.*)/) || ['', '']
    const [current] = updateOut.match(/Installed: (.*)/) || ['', '']
    return {
      latest: latest || '',
      current: current || ''
    }
  }
  
  public async getNpmPackageVersion() {
    const updateOut = JSON.parse(await execAsync('npm show @xyo-network/pi-bridge-server time --json'))
    const versions = Object.keys(updateOut)
    const latest = versions.length ? versions[versions.length - 1] : ''
    const current = npmPackage.version
    return { latest, current: current }
  }
}

const execAsync = (cmd: string): Promise<string> => {
  const { exec } = require('child_process')
  return new Promise((res, rej) => {
    exec(cmd, (e: Error | null, stdout: string, _stderr: string) => {
      if (e) rej(e)
      // else if (stderr) rej(stderr)
      else res(stdout)
    })
  })
}
