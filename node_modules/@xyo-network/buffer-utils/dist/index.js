"use strict";
/*
 * @Author: XY | The Findables Company <ryanxyo>
 * @Date:   Tuesday, 20th November 2018 10:04:37 am
 * @Email:  developer@xyfindables.com
 * @Filename: index.ts
 * @Last modified by: ryanxyo
 * @Last modified time: Wednesday, 6th March 2019 4:42:51 pm
 * @License: All Rights Reserved
 * @Copyright: Copyright XY | The Findables Company
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.readFloatFromBuffer = exports.readDoubleFromBuffer = exports.floatToBuffer = exports.doubleToBuffer = exports.signedIntegerToBuffer = exports.unsignedIntegerToBuffer = exports.writePointTo32ByteBuffer = exports.readIntegerFromBuffer = exports.writeIntegerToBuffer = void 0;
const errors_1 = require("@xyo-network/errors");
const utils_1 = require("@xyo-network/utils");
/** A helper function to write a number to a buffer that supports multiple sizes and signings */
function writeIntegerToBuffer(numberToWrite, bytes, isSigned, buffer, offset) {
    const buf = buffer || Buffer.alloc(bytes);
    const bufOffset = offset || 0;
    if (isSigned) {
        switch (bytes) {
            case 1:
                buf.writeInt8(numberToWrite, bufOffset);
                return buf;
            case 2:
                buf.writeInt16BE(numberToWrite, bufOffset);
                return buf;
            case 4:
                buf.writeInt32BE(numberToWrite, bufOffset);
                return buf;
            default:
                throw new errors_1.XyoError(`Could not write number to buffer`);
        }
    }
    switch (bytes) {
        case 1:
            buf.writeUInt8(numberToWrite, bufOffset);
            return buf;
        case 2:
            buf.writeUInt16BE(numberToWrite, bufOffset);
            return buf;
        case 4:
            buf.writeUInt32BE(numberToWrite, bufOffset);
            return buf;
        case 8:
            const bnBuffer = new utils_1.BN(numberToWrite).toBuffer('be', 8);
            let i = 0;
            while (i < 8) {
                buf[i + bufOffset] = bnBuffer[i];
                i += 1;
            }
            return buf;
        default:
            throw new errors_1.XyoError(`Could not write number to buffer`);
    }
}
exports.writeIntegerToBuffer = writeIntegerToBuffer;
/** A helper function to read a number from a buffer based off of sign by */
function readIntegerFromBuffer(buffer, bytes, isSigned, offset) {
    const bufOffset = offset || 0;
    if (isSigned) {
        switch (bytes) {
            case 1:
                return buffer.readInt8(bufOffset);
            case 2:
                return buffer.readInt16BE(bufOffset);
            case 4:
                return buffer.readInt32BE(bufOffset);
            default:
                throw new errors_1.XyoError(`Could not read number from buffer`);
        }
    }
    switch (bytes) {
        case 1:
            return buffer.readUInt8(bufOffset);
        case 2:
            return buffer.readUInt16BE(bufOffset);
        case 4:
            return buffer.readUInt32BE(bufOffset);
        case 8:
            return new utils_1.BN(buffer.subarray(bufOffset || 0, bufOffset + bytes)).toNumber();
        default:
            throw new errors_1.XyoError(`Could not read number from buffer`);
    }
}
exports.readIntegerFromBuffer = readIntegerFromBuffer;
function writePointTo32ByteBuffer(point) {
    if (point.length === 32) {
        return point;
    }
    const dest = Buffer.alloc(32);
    const offset = dest.length - point.length;
    let index = 0;
    while (index < point.length) {
        dest[offset + index] = point[index];
        index += 1;
    }
    return dest;
}
exports.writePointTo32ByteBuffer = writePointTo32ByteBuffer;
function unsignedIntegerToBuffer(num) {
    let buf;
    if (num <= Math.pow(2, 8) - 1) {
        buf = Buffer.alloc(1);
        buf.writeUInt8(num, 0);
    }
    else if (num <= Math.pow(2, 16) - 1) {
        buf = Buffer.alloc(2);
        buf.writeUInt16BE(num, 0);
    }
    else if (num <= Math.pow(2, 32) - 1) {
        buf = Buffer.alloc(4);
        buf.writeUInt32BE(num, 0);
    }
    else if (num > Math.pow(2, 32)) {
        buf = new utils_1.BN(num).toBuffer('be');
    }
    else {
        throw new errors_1.XyoError('This should never happen');
    }
    return buf;
}
exports.unsignedIntegerToBuffer = unsignedIntegerToBuffer;
function signedIntegerToBuffer(num) {
    let buf;
    if (num <= Math.pow(2, 7) - 1) {
        buf = Buffer.alloc(1);
        buf.writeInt8(num, 0);
    }
    else if (num <= Math.pow(2, 15) - 1) {
        buf = Buffer.alloc(2);
        buf.writeInt16BE(num, 0);
    }
    else if (num <= Math.pow(2, 31) - 1) {
        buf = Buffer.alloc(4);
        buf.writeInt32BE(num, 0);
    }
    else if (num > Math.pow(2, 31)) {
        throw new errors_1.XyoError('This is not yet supported');
    }
    else {
        throw new errors_1.XyoError('This should never happen');
    }
    return buf;
}
exports.signedIntegerToBuffer = signedIntegerToBuffer;
function doubleToBuffer(num) {
    const b = Buffer.alloc(8);
    b.writeDoubleBE(num, 0);
    return b;
}
exports.doubleToBuffer = doubleToBuffer;
function floatToBuffer(num) {
    const b = Buffer.alloc(4);
    b.writeFloatBE(num, 0);
    return b;
}
exports.floatToBuffer = floatToBuffer;
function readDoubleFromBuffer(buffer, offset = 0) {
    return buffer.readDoubleBE(offset);
}
exports.readDoubleFromBuffer = readDoubleFromBuffer;
function readFloatFromBuffer(buffer, offset = 0) {
    return buffer.readFloatBE(offset);
}
exports.readFloatFromBuffer = readFloatFromBuffer;
//# sourceMappingURL=index.js.map