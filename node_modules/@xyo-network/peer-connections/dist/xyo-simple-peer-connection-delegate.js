"use strict";
/*
 * @Author: XY | The Findables Company <ryanxyo>
 * @Date:   Tuesday, 20th November 2018 11:29:03 am
 * @Email:  developer@xyfindables.com
 * @Filename: xyo-simple-peer-connection-delegate.ts
 * @Last modified by: ryanxyo
 * @Last modified time: Friday, 7th December 2018 11:44:25 am
 * @License: All Rights Reserved
 * @Copyright: Copyright XY | The Findables Company
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.XyoSimplePeerConnectionDelegate = void 0;
const network_1 = require("@xyo-network/network");
const base_1 = require("@xyo-network/base");
class XyoSimplePeerConnectionDelegate extends base_1.XyoBase {
    constructor(network, catalogue, peerConnectionHandler) {
        super();
        this.network = network;
        this.catalogue = catalogue;
        this.peerConnectionHandler = peerConnectionHandler;
    }
    provideConnection() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.network.find(this.catalogue);
        });
    }
    stopProvidingConnections() {
        return this.network.stopServer();
    }
    doClientNegotiation(networkPipe) {
        return __awaiter(this, void 0, void 0, function* () {
            const pipe = networkPipe;
            const firstMessage = this.getFirstMessage(this.combineCatalogueItems(this.catalogue.getCurrentCatalogue()));
            const encodedResponse = yield pipe.send(firstMessage.bytesToSend, true);
            if (encodedResponse) {
                const { serversChoices, response } = this.getChoiceAndResponse(encodedResponse);
                if (serversChoices.length !== 1) {
                    // this is thrown when the server chooses more than one item
                    throw Error("Invalid choice!");
                }
                pipe.initiationData = response;
                const serversChoice = serversChoices[0];
                return { pipe, serversChoice };
            }
            throw Error("No response!");
        });
    }
    handlePeerConnection(networkPipe) {
        return __awaiter(this, void 0, void 0, function* () {
            const initiationData = networkPipe.initiationData;
            if (initiationData) {
                // is a server, networkPipe.initiationData is the clients catalogue
                const clientCatalogueItems = this.getClientCatalogue(initiationData);
                return this.peerConnectionHandler.handlePeerConnection(networkPipe, undefined, clientCatalogueItems, 
                // this is false
                initiationData === undefined);
            }
            // is a client, networkPipe.initiationData is null, so we must send them our catalogue
            // the pipe here is the new pipe with contained data (the servers response)
            const { pipe, serversChoice } = yield this.doClientNegotiation(networkPipe);
            return this.peerConnectionHandler.handlePeerConnection(pipe, serversChoice, undefined, 
            // this is true
            initiationData === undefined);
        });
    }
    getFirstMessage(catalogue) {
        // Tell the other node this is the catalogue item you chose
        const catalogueBuffer = Buffer.alloc(network_1.CATALOGUE_LENGTH_IN_BYTES);
        const sizeOfCatalogueInBytesBuffers = Buffer.alloc(network_1.CATALOGUE_SIZE_OF_SIZE_BYTES);
        catalogueBuffer.writeUInt32BE(catalogue, 0);
        sizeOfCatalogueInBytesBuffers.writeUInt8(network_1.CATALOGUE_LENGTH_IN_BYTES, 0);
        // Build the final message
        const bytesToSend = Buffer.concat([
            sizeOfCatalogueInBytesBuffers,
            catalogueBuffer,
        ]);
        return { bytesToSend };
    }
    getClientCatalogue(bytes) {
        if (bytes.length < 2) {
            return [];
        }
        const encodedCatalogue = bytes.subarray(1);
        return (0, network_1.bufferToCatalogueItems)(encodedCatalogue);
    }
    combineCatalogueItems(items) {
        let int = 0;
        items.forEach((item) => {
            int = int | item;
        });
        return int;
    }
    getChoiceAndResponse(message) {
        const sizeOfCat = message.readUInt8(0);
        const response = message.subarray(1 + sizeOfCat, message.length);
        const cat = message.subarray(1, sizeOfCat + 1);
        const serversChoices = (0, network_1.bufferToCatalogueItems)(cat);
        return { serversChoices, response };
    }
}
exports.XyoSimplePeerConnectionDelegate = XyoSimplePeerConnectionDelegate;
//# sourceMappingURL=xyo-simple-peer-connection-delegate.js.map