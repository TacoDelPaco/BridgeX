"use strict";
/*
 * @Author: XY | The Findables Company <ryanxyo>
 * @Date:   Tuesday, 20th November 2018 11:18:23 am
 * @Email:  developer@xyfindables.com
 * @Filename: xyo-peer-connection-handler.ts
 * @Last modified by: ryanxyo
 * @Last modified time: Tuesday, 20th November 2018 11:24:59 am
 * @License: All Rights Reserved
 * @Copyright: Copyright XY | The Findables Company
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.XyoPeerConnectionHandler = void 0;
const base_1 = require("@xyo-network/base");
const network_1 = require("@xyo-network/network");
class XyoPeerConnectionHandler extends base_1.XyoBase {
    constructor(router, categoryResolver) {
        super();
        this.router = router;
        this.categoryResolver = categoryResolver;
    }
    // this is when a SERVER chooses the flag for the client
    handlePeerConnection(networkPipe, choice, toChoose, didInit) {
        return __awaiter(this, void 0, void 0, function* () {
            if (choice && toChoose) {
                this.logInfo(`Can not choose and have a choice`);
                yield networkPipe.close();
                return;
            }
            const category = this.resolveCategory(choice, toChoose);
            if (!category) {
                this.logInfo(`Unable to resolve a category ${category}, closing connection`);
                yield networkPipe.close();
                return;
            }
            // this choice also needs to be flipped
            const handler = this.router.getHandler(category);
            if (!handler) {
                this.logInfo(`Could not find handler for category ${category}, closing connection`);
                yield networkPipe.close();
                return;
            }
            let correctAsymmetricCategory = category;
            if (toChoose) {
                correctAsymmetricCategory = (0, network_1.flipChoice)(category);
            }
            yield handler.handle(networkPipe, didInit, correctAsymmetricCategory);
        });
    }
    resolveCategory(choice, toChoose) {
        if (choice) {
            return choice;
        }
        if (toChoose) {
            return this.categoryResolver.resolveCategory(toChoose);
        }
        return undefined;
    }
}
exports.XyoPeerConnectionHandler = XyoPeerConnectionHandler;
//# sourceMappingURL=xyo-peer-connection-handler.js.map