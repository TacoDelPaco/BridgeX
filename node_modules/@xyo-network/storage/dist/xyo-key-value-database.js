"use strict";
/*
 * @Author: XY | The Findables Company <ryanxyo>
 * @Date:   Tuesday, 20th November 2018 1:25:50 pm
 * @Email:  developer@xyfindables.com
 * @Filename: xyo-key-value-database.ts
 * @Last modified by: ryanxyo
 * @Last modified time: Tuesday, 11th December 2018 9:58:22 am
 * @License: All Rights Reserved
 * @Copyright: Copyright XY | The Findables Company
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = require("@xyo-network/base");
/**
 * Provides namespaces for an otherwise non-namespaced storage-provider
 *
 * @export
 * @class XyoKeyValueDatabase
 * @extends {XyoBase}
 */
class XyoKeyValueDatabase extends base_1.XyoBase {
    /**
     * Creates an instance of XyoKeyValueDatabase.
     * @param {IXyoStorageProvider} storageProvider The storage provider that will store the namespaces
     * @memberof XyoKeyValueDatabase
     */
    constructor(storageProvider) {
        super();
        this.storageProvider = storageProvider;
        this.namespaceKey = Buffer.from('namespaces');
    }
    /**
     * Get or creates a namespace in the storage provider. The `IXyoStorageProvider` returned
     * is a storage provider in the protected namespace
     *
     * @param {string} namespace
     * @returns {Promise<IXyoStorageProvider>}
     * @memberof XyoKeyValueDatabase
     */
    getOrCreateNamespace(namespace) {
        return __awaiter(this, void 0, void 0, function* () {
            const namespaceExists = yield this.storageProvider.containsKey(this.namespaceKey);
            let namespaceValue = [];
            let shouldUpdateNamespaceList = false;
            if (namespaceExists) {
                const namespaceBufferValue = yield this.storageProvider.read(this.namespaceKey);
                namespaceValue = JSON.parse(namespaceBufferValue.toString());
                const index = namespaceValue.indexOf(namespace);
                if (index === -1) { // does not ext
                    shouldUpdateNamespaceList = true;
                    namespaceValue.push(namespace);
                }
            }
            else {
                shouldUpdateNamespaceList = true;
                namespaceValue.push(namespace);
            }
            if (shouldUpdateNamespaceList) {
                yield this.storageProvider.write(this.namespaceKey, Buffer.from(base_1.XyoBase.stringify(namespaceValue)));
            }
            return new XyoNamespacedStorageProvider(this.storageProvider, namespace);
        });
    }
}
exports.XyoKeyValueDatabase = XyoKeyValueDatabase;
// tslint:disable-next-line:max-classes-per-file
class XyoNamespacedStorageProvider {
    constructor(proxyStorageProvider, namespace) {
        this.proxyStorageProvider = proxyStorageProvider;
        this.namespace = Buffer.from(`${namespace}.`);
    }
    /** Should persist the value for the corresponding key */
    write(key, value) {
        return this.proxyStorageProvider.write(this.getProxyKey(key), value);
    }
    /** Attempts to the read the value for key, returns `undefined` if it does not exist */
    read(key) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.proxyStorageProvider.read(this.getProxyKey(key));
        });
    }
    /** Returns a list of all the keys in storage */
    getAllKeys() {
        return __awaiter(this, void 0, void 0, function* () {
            const allKeys = yield this.proxyStorageProvider.getAllKeys();
            return allKeys.map((key) => {
                if (key.length < this.namespace.length) {
                    return undefined;
                }
                if (!key.slice(0, this.namespace.length).equals(this.namespace)) {
                    return undefined;
                }
                return key.slice(this.namespace.length);
            })
                .filter(v => v);
        });
    }
    /** Removes a key from storage */
    delete(key) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.proxyStorageProvider.delete(this.getProxyKey(key));
        });
    }
    /** Returns true if the key exists in storage, false otherwise */
    containsKey(key) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.proxyStorageProvider.containsKey(this.getProxyKey(key));
        });
    }
    getProxyKey(key) {
        return Buffer.concat([
            this.namespace,
            key
        ]);
    }
}
//# sourceMappingURL=xyo-key-value-database.js.map