"use strict";
/*
 * @Author: XY | The Findables Company <ryanxyo>
 * @Date:   Friday, 8th March 2019 1:32:51 pm
 * @Email:  developer@xyfindables.com
 * @Filename: index.ts
 * @Last modified by: ryanxyo
 * @Last modified time: Friday, 8th March 2019 2:58:53 pm
 * @License: All Rights Reserved
 * @Copyright: Copyright XY | The Findables Company
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = require("@xyo-network/base");
const errors_1 = require("@xyo-network/errors");
/**
 * Provides local content addressable service. Additionally provides key and value
 * converters so keys and values can be processed before persistance. This may be useful
 * for testing so values are stored and retrieved in readable hexadecimal or useful for
 * encryption before persisting.
 *
 * @export
 * @class XyoLocalContentService
 * @extends {XyoBase}
 * @implements {IXyoContentAddressableService}
 */
class XyoLocalContentService extends base_1.XyoBase {
    constructor(hashProvider, storageProvider, keyConverter, valConverter) {
        super();
        this.hashProvider = hashProvider;
        this.storageProvider = storageProvider;
        this.keyConverter = keyConverter;
        this.valConverter = valConverter;
    }
    get(key) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const derivedKey = contentAddressableToString(key);
                return this.storageProvider.read(this.keyConverter ? this.keyConverter(Buffer.from(derivedKey)) : Buffer.from(derivedKey));
            }
            catch (e) { // swallow
                return undefined;
            }
        });
    }
    add(value) {
        return __awaiter(this, void 0, void 0, function* () {
            const v = value instanceof Buffer ? value : value.serialize();
            const keyHash = yield this.hashProvider.createHash(v);
            const strKey = keyHash.getHash().toString();
            yield this.storageProvider.write(this.keyConverter ? this.keyConverter(Buffer.from(strKey)) : Buffer.from(strKey), this.valConverter ? this.valConverter(Buffer.from(v)) : Buffer.from(v));
            return strKey;
        });
    }
}
exports.XyoLocalContentService = XyoLocalContentService;
function contentAddressableToString(contentAddress) {
    if (!contentAddress)
        throw new errors_1.XyoError(`contentAddress must be a value`);
    if (typeof contentAddress === 'string')
        return contentAddress;
    if (contentAddress instanceof Buffer)
        return contentAddress.toString();
    if (contentAddress.schemaObjectId)
        return contentAddress.serialize().toString();
    throw new errors_1.XyoError(`Could not convert contentAddressable to string`);
}
exports.contentAddressableToString = contentAddressableToString;
//# sourceMappingURL=index.js.map