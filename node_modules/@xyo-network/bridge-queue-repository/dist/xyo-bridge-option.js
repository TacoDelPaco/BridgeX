"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const origin_chain_1 = require("@xyo-network/origin-chain");
class XyoBridgeOption {
    constructor(blocks, bridge, hasher) {
        this.blocksInTransit = [];
        this.blockRepo = blocks;
        this.bridgeQueue = bridge;
        this.hasher = hasher;
    }
    signed() {
        return __awaiter(this, void 0, void 0, function* () {
            this.blocksInTransit = this.bridgeQueue.getBlocksToBridge();
            const hashes = [];
            for (let i = 0; i <= this.blocksInTransit.length - 1; i++) {
                try {
                    const block = this.blocksInTransit[i];
                    const boundWitness = yield this.blockRepo.getOriginBlockByHash(block.hash);
                    if (boundWitness) {
                        const hash = yield this.hasher.createHash(boundWitness.getSigningData());
                        hashes.push(hash);
                    }
                }
                catch (e) {
                    console.log(`Missing origin block ${this.blocksInTransit[i].hash.toString("hex")}`);
                }
            }
            return new origin_chain_1.XyoBridgeHashSet(hashes);
        });
    }
    unsigned() {
        return __awaiter(this, void 0, void 0, function* () {
            const blocks = [];
            for (let i = 0; i <= this.blocksInTransit.length - 1; i++) {
                try {
                    const block = this.blocksInTransit[i];
                    const boundWitness = yield this.blockRepo.getOriginBlockByHash(block.hash);
                    if (boundWitness) {
                        blocks.push(boundWitness);
                    }
                }
                catch (error) {
                    console.log(`Missing origin block ${this.blocksInTransit[i].hash.toString("hex")}`);
                }
            }
            return new origin_chain_1.XyoBridgeBlockSet(blocks);
        });
    }
    onCompleted() {
        this.bridgeQueue.onBlocksBridged(this.blocksInTransit);
    }
}
exports.XyoBridgeOption = XyoBridgeOption;
//# sourceMappingURL=xyo-bridge-option.js.map