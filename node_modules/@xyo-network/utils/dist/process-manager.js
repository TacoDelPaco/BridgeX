"use strict";
/*
* @Author: XY | The Findables Company <ryanxyo>
* @Date:   Thursday, 13th December 2018 1:17:30 pm
* @Email:  developer@xyfindables.com
* @Filename: process-manager.ts
* @Last modified by: ryanxyo
* @Last modified time: Friday, 15th February 2019 10:35:41 am
* @License: All Rights Reserved
* @Copyright: Copyright XY | The Findables Company
*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProcessManager = void 0;
const base_1 = require("@xyo-network/base");
class ProcessManager {
    constructor(program) {
        this.program = program;
        this.unhandledRejections = new Map();
    }
    manage(process) {
        return __awaiter(this, void 0, void 0, function* () {
            process.on('beforeExit', (exitCode) => {
                base_1.XyoBase.unschedule();
                console.log(`Will exit with exitCode ${exitCode}`);
            })
                .on('exit', (exitCode) => __awaiter(this, void 0, void 0, function* () {
                base_1.XyoBase.unschedule();
                if (this.program.canStop()) {
                    yield this.program.stop();
                }
                console.log(`Exiting with exitCode ${exitCode}`);
            }))
                .on('multipleResolves', (type, _promise, value) => {
                console.error(`A promise with type ${type} was resolved multiple times with value ${value}. Will exit.`);
                setImmediate(() => process.exit(1));
            })
                .on('unhandledRejection', (reason, promise) => __awaiter(this, void 0, void 0, function* () {
                console.error(`There was an unhandled rejection ${reason} ${promise}`);
                this.unhandledRejections.set(promise, reason);
                if (this.program.canStop()) {
                    yield this.program.stop();
                }
            }))
                .on('rejectionHandled', (promise) => {
                console.error(`Reject handled ${promise}`);
                this.unhandledRejections.delete(promise);
            })
                .on('uncaughtException', (err) => __awaiter(this, void 0, void 0, function* () {
                console.error(`Uncaught exception. Will exit.\n\n${err.message}\n\n${err.stack}`);
                if (this.program.canStop()) {
                    yield this.program.stop();
                }
                setImmediate(() => process.exit(1));
            }))
                .on('warning', (warning) => {
                console.warn(warning.name); // Print the warning name
                console.warn(warning.message); // Print the warning message
                if (warning.stack) {
                    console.warn(warning.stack); // Print the stack trace
                }
            })
                .on('SIGINT', () => __awaiter(this, void 0, void 0, function* () {
                if (this.program && this.program.canStop()) {
                    console.log(`Shutting down`);
                    console.log(`Shutdown. Will Exit.`);
                    yield this.program.stop();
                }
                process.exit(0);
            }));
            try {
                yield this.program.initialize();
                yield this.program.start();
            }
            catch (e) {
                console.error(`Uncaught error in process-manager`, e);
                throw e;
            }
        });
    }
}
exports.ProcessManager = ProcessManager;
//# sourceMappingURL=process-manager.js.map