"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
class XyoStorageBridgeQueueRepository {
    constructor(store) {
        this.memoryBase = [];
        this.storage = store;
    }
    removeHashes(items) {
        items.forEach((hash) => {
            this.removeHash(hash);
        });
    }
    getQueue() {
        return this.memoryBase;
    }
    setQueue(queue) {
        this.memoryBase = queue;
    }
    addQueueItem(item) {
        const insertIndex = this.getInsertIndex(item);
        this.memoryBase.splice(insertIndex, 0, item);
        this.memoryBase.join();
    }
    getLowestWeight(n) {
        if (this.memoryBase.length === 0 || n === 0) {
            return [];
        }
        const itemsToReturn = [];
        for (let i = 0; i < Math.min(n, this.memoryBase.length); i++) {
            itemsToReturn.push(this.memoryBase[i]);
        }
        return itemsToReturn;
    }
    incrementWeights(hashes) {
        hashes.forEach((hash) => {
            for (let i = 0; i <= this.memoryBase.length - 1; i++) {
                if (this.memoryBase[i].hash === hash) {
                    this.memoryBase[i].weight++;
                }
            }
        });
    }
    commit() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.storage.write(XyoStorageBridgeQueueRepository.QUEUE_KEY, Buffer.from(JSON.stringify(this.memoryBase)));
        });
    }
    restore() {
        return __awaiter(this, void 0, void 0, function* () {
            const hasIndex = yield this.storage.containsKey(XyoStorageBridgeQueueRepository.QUEUE_KEY);
            if (hasIndex) {
                const encodedState = yield this.storage.read(XyoStorageBridgeQueueRepository.QUEUE_KEY);
                if (encodedState) {
                    const string = encodedState.toString("utf8");
                    const json = JSON.parse(string);
                    for (let i = 0; i <= json.length - 1; i++) {
                        if (json[i].hash.type === 'Buffer') {
                            json[i].hash = new Buffer(json[i].hash);
                        }
                    }
                    this.memoryBase = json;
                }
            }
        });
    }
    removeHash(hash) {
        this.memoryBase = this.memoryBase.filter((i) => {
            return i.hash !== hash;
        });
    }
    getInsertIndex(item) {
        if (this.memoryBase.length === 0) {
            return 0;
        }
        for (let i = 0; i < this.memoryBase.length - 1; i++) {
            if (this.memoryBase[i].weight >= item.weight) {
                return i;
            }
        }
        return 0;
    }
}
XyoStorageBridgeQueueRepository.QUEUE_KEY = Buffer.from("BRIDGE_QUEUE");
exports.XyoStorageBridgeQueueRepository = XyoStorageBridgeQueueRepository;
//# sourceMappingURL=bridge-queue-repository-storage.js.map