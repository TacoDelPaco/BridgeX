"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const npmPackage = require('../package.json');
// tslint:disable-next-line
let mockPassword = '';
// tslint:disable-next-line
let mockPublicKey = '000c4114ab1adccbf3205ef2b524fe502fcdd2ee91ce3ea72898c6452cca510039e4ebfa3c7f133bfb415e1835337ecaed48195d576d5720c8cd729543a93e9e9b56ad';
// tslint:disable-next-line
let mockPaymentKey = '0x4aef1Fd68C9D0b17d85E0f4e90604F6c92883F18';
let mockArchivists = [];
class BridgeConfigurationManager {
    getPublicKey() {
        return __awaiter(this, void 0, void 0, function* () {
            return mockPublicKey;
        });
    }
    getPaymentKey() {
        return __awaiter(this, void 0, void 0, function* () {
            // tslint:disable-next-line
            return mockPaymentKey;
        });
    }
    setPaymentKey(paymentKey) {
        return __awaiter(this, void 0, void 0, function* () {
            mockPaymentKey = paymentKey;
            return paymentKey;
        });
    }
    setDefaultArchivist(id) {
        return __awaiter(this, void 0, void 0, function* () {
            return {
                id
            };
        });
    }
    getDefaultArchivist() {
        return __awaiter(this, void 0, void 0, function* () {
            return {};
        });
    }
    attachArchivist(dns, port) {
        return __awaiter(this, void 0, void 0, function* () {
            const id = `http://${dns}:${port}`;
            const archivist = {
                id,
                dns,
                port
            };
            mockArchivists.push(archivist);
            return archivist;
        });
    }
    detachArchivist(id) {
        return __awaiter(this, void 0, void 0, function* () {
            mockArchivists = mockArchivists.filter(archivist => archivist.id !== id);
            return {
                id
            };
        });
    }
    getAttachedArchivists() {
        return __awaiter(this, void 0, void 0, function* () {
            return mockArchivists;
        });
    }
    verifyPin(pin) {
        return __awaiter(this, void 0, void 0, function* () {
            return pin === mockPassword;
        });
    }
    updatePin(oldPin, newPin) {
        return __awaiter(this, void 0, void 0, function* () {
            if (mockPassword && oldPin !== mockPassword)
                throw new Error('Invalid');
            mockPassword = newPin;
            return true;
        });
    }
    isConfigured() {
        return __awaiter(this, void 0, void 0, function* () {
            return !!mockPassword;
        });
    }
    forceUpdate() {
        return __awaiter(this, void 0, void 0, function* () {
            execAsync('echo "Unattended upgrade"')
                .then(d => console.log('UNATTENDED', d))
                .catch(e => console.log('ERROR', e));
            return true;
        });
    }
    factoryReset() {
        return __awaiter(this, void 0, void 0, function* () {
            yield execAsync('echo "sudo rm -rf /var/opt/bridge-store && sudo reboot"');
        });
    }
    checkForUpdates() {
        return __awaiter(this, void 0, void 0, function* () {
            yield execAsync('echo "apt upgrade"');
            return true;
        });
    }
    lastResort() {
        return __awaiter(this, void 0, void 0, function* () {
            execAsync("sudo sh -c 'curl -L https://s3.amazonaws.com/xyo-bridge-images/last-resort.sh | sh'")
                .then(d => console.log('Last resort', d))
                .catch(e => console.log('ERROR', e));
            return true;
        });
    }
    tailLog(pathname, n = 5) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const stdOut = yield execAsync(`tail -${n} ${pathname}`);
                return stdOut;
            }
            catch (e) {
                return e.message;
            }
        });
    }
    getAptPackageVersion() {
        return __awaiter(this, void 0, void 0, function* () {
            const updateOut = yield execAsync('echo "xyo-bridge\n\tInstalled: 0.0.50\n\tCandidate: 0.0.51\n\tVersion table:"');
            const [a, latest] = updateOut.match(/Candidate: (.*)/) || ['', ''];
            const [b, current] = updateOut.match(/Installed: (.*)/) || ['', ''];
            return {
                latest: latest || '',
                current: current || ''
            };
        });
    }
    getNpmPackageVersion() {
        return __awaiter(this, void 0, void 0, function* () {
            const updateOut = JSON.parse(yield execAsync('npm show @xyo-network/pi-bridge-server time --json'));
            const versions = Object.keys(updateOut);
            const latest = versions.length ? versions[versions.length - 1] : '';
            const current = npmPackage.version;
            return { latest, current: '0.123.0' };
        });
    }
}
exports.BridgeConfigurationManager = BridgeConfigurationManager;
const execAsync = (cmd) => {
    const { exec } = require('child_process');
    return new Promise((res, rej) => {
        exec(cmd, (e, stdout, stderr) => {
            if (e)
                rej(e);
            // else if (stderr) rej(stderr)
            else
                res(stdout);
        });
    });
};
//# sourceMappingURL=bridge-configuration-manager.js.map