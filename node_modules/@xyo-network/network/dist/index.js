"use strict";
/*
 * @Author: XY | The Findables Company <ryanxyo>
 * @Date:   Tuesday, 20th November 2018 10:18:42 am
 * @Email:  developer@xyfindables.com
 * @Filename: index.ts
 * @Last modified by: ryanxyo
 * @Last modified time: Wednesday, 13th February 2019 1:28:15 pm
 * @License: All Rights Reserved
 * @Copyright: Copyright XY | The Findables Company
 */
Object.defineProperty(exports, "__esModule", { value: true });
const catalogue_item_1 = require("./catalogue-item");
var catalogue_item_2 = require("./catalogue-item");
exports.CatalogueItem = catalogue_item_2.CatalogueItem;
var xyo_mock_network_pipe_1 = require("./xyo-mock-network-pipe");
exports.XyoMockNetworkPipe = xyo_mock_network_pipe_1.XyoMockNetworkPipe;
/**
 * Some very important numbers that factor into the catalogue negotiation protocol
 */
/** The current number of bytes that encode the length if the catalogue */
exports.CATALOGUE_LENGTH_IN_BYTES = 4;
/** This number of bytes allowed to encode how big the catalogue can be */
exports.CATALOGUE_SIZE_OF_SIZE_BYTES = 1;
/**
 * When a payload is passed it is padded with the length of bytes of the payload.
 * It gets 4 bytes to do so
 */
exports.CATALOGUE_SIZE_OF_PAYLOAD_BYTES = 4;
/**
 * A utility function for translating a buffer to a list of catalogues items
 * that another node is willing to do.
 *
 * @param buffer The data buffer to read and translate
 */
function bufferToCatalogueItems(buffer) {
    const values = readNumberFromBufferCatalogue(buffer);
    return [
        (catalogue_item_1.CatalogueItem.BOUND_WITNESS & values) > 0 ? catalogue_item_1.CatalogueItem.BOUND_WITNESS : null,
        (catalogue_item_1.CatalogueItem.TAKE_ORIGIN_CHAIN & values) > 0 ? catalogue_item_1.CatalogueItem.TAKE_ORIGIN_CHAIN : null,
        (catalogue_item_1.CatalogueItem.GIVE_ORIGIN_CHAIN & values) > 0 ? catalogue_item_1.CatalogueItem.GIVE_ORIGIN_CHAIN : null
    ]
        .filter(catalogueItem => catalogueItem !== null);
}
exports.bufferToCatalogueItems = bufferToCatalogueItems;
function flipChoice(choice) {
    if (catalogue_item_1.CatalogueItem.GIVE_ORIGIN_CHAIN === choice) {
        return catalogue_item_1.CatalogueItem.TAKE_ORIGIN_CHAIN;
    }
    if (catalogue_item_1.CatalogueItem.TAKE_ORIGIN_CHAIN === choice) {
        return catalogue_item_1.CatalogueItem.GIVE_ORIGIN_CHAIN;
    }
    return choice;
}
exports.flipChoice = flipChoice;
const readNumberFromBufferCatalogue = (buffer) => {
    if (buffer.length === 4) {
        return buffer.readUInt32BE(0);
    }
    if (buffer.length === 2) {
        return buffer.readUInt16BE(0);
    }
    if (buffer.length === 1) {
        return buffer.readUInt8(0);
    }
    return 0;
};
/** Returns a number, which is feature-mask representing CatalogueItems */
function catalogueItemsToMask(catalogueItems) {
    return catalogueItems.reduce((sum, item) => sum + item, 0);
}
exports.catalogueItemsToMask = catalogueItemsToMask;
class XyoNetworkProcedureCatalogue {
    constructor() {
        this.catalogue = [];
    }
    canDo(catalogueItem) {
        return this.catalogue.indexOf(catalogueItem) > -1;
    }
    getCurrentCatalogue() {
        return this.catalogue;
    }
    setCatalogue(catalogue) {
        this.catalogue = catalogue;
    }
}
exports.XyoNetworkProcedureCatalogue = XyoNetworkProcedureCatalogue;
//# sourceMappingURL=index.js.map